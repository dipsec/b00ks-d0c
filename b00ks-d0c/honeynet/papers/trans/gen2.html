<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 10">
<meta name=Originator content="Microsoft Word 10">
<link rel=File-List href="GenII%20Honeynets-Dateien/filelist.xml">
<title>GenII Honeynets</title>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="State"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="place"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="time"/>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Jochen Berner</o:Author>
  <o:LastAuthor>Jochen Berner</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>0</o:TotalTime>
  <o:Created>2003-09-16T10:40:00Z</o:Created>
  <o:LastSaved>2003-09-16T10:40:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>5643</o:Words>
  <o:Characters>35558</o:Characters>
  <o:Company>Networkers AG</o:Company>
  <o:Lines>296</o:Lines>
  <o:Paragraphs>82</o:Paragraphs>
  <o:CharactersWithSpaces>41119</o:CharactersWithSpaces>
  <o:Version>10.4219</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:AutoHyphenation/>
  <w:HyphenationZone>21</w:HyphenationZone>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:1627421319 -2147483648 8 0 66047 0;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536871559 0 0 0 415 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Standard;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;
	font-weight:bold;}
h2
	{mso-style-next:Standard;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:14.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
h3
	{mso-style-link:"Überschrift 3 Char";
	mso-style-next:Standard;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	mso-text-animation:none;
	text-decoration:none;
	text-underline:none;
	text-decoration:none;
	text-line-through:none;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
pre
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
span.text1
	{mso-style-name:text1;
	mso-ansi-font-size:8.0pt;
	mso-bidi-font-size:8.0pt;
	font-family:Verdana;
	mso-ascii-font-family:Verdana;
	mso-hansi-font-family:Verdana;
	color:black;}
span.berschrift3Char
	{mso-style-name:"Überschrift 3 Char";
	mso-style-link:"Überschrift 3";
	mso-ansi-font-size:13.0pt;
	mso-bidi-font-size:13.0pt;
	font-family:Arial;
	mso-ascii-font-family:Arial;
	mso-hansi-font-family:Arial;
	mso-bidi-font-family:Arial;
	mso-ansi-language:DE;
	mso-fareast-language:DE;
	mso-bidi-language:AR-SA;
	font-weight:bold;}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:70.85pt 70.85pt 2.0cm 70.85pt;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:1619146093;
	mso-list-type:hybrid;
	mso-list-template-ids:-1034490804 67567617 67567619 67567621 67567617 67567619 67567621 67567617 67567619 67567621;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Normale Tabelle";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="2050"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=DE link=blue vlink=purple style='tab-interval:35.4pt'>

<div class=Section1>

<h1 align=center style='text-align:center'><span style='font-size:20.0pt'>GenII
Honeynets<o:p></o:p></span></h1>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h2>Einfacher aufzusetzen, schwerer zu entdecken, sicherer zu betreiben</h2>

<p class=MsoNormal><span style='font-family:Arial'>Letzte Änderung: 27.06.2003<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Das
GenII Honeynet ist der nächste Schritt in der Entwicklung der
Honeynet-Technologie. Durch Anwendung neuer Techniken, entwickelt von den Mitgliedern
des Honeynet Projects und der <span class=SpellE>Security</span> <span
class=SpellE>Community</span>, verbessert ein GenII Honeynet Flexibilität,
Verwaltbarkeit und Sicherheit eines Honeynet Installation. Dieser Artikel
stellt die Technologie vor und kann als <span class=SpellE>Schritt-für-Schritt</span>
Anleitung zum Bau eines GenII Honeynets dienen, das denen ähnelt, das die
Mitglieder des Projektes verwenden. Es wird angenommen, das Sie bereits die
Konzepte die in <a href="http://www.honeynet.org/papers/honeynets/"><span
class=SpellE>Know</span> <span class=SpellE>Your</span> <span class=SpellE>Enemy</span>:
Honeynets</a> (oder der deutschen Übersetzung) vorgestellt werden gelesen und
verstanden haben.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Dieser
Artikel ist ein vollständiger Überblick über alle Komponenten eines GenII Honeynets.
Der erste Abschnitt stellt das Konzept einer Honeywall vor, die Stelle, an der
sich die Verwaltungsmöglichkeiten für das Netzwerk bündeln. Im Abschnitt „Datenkontrolle“
sprechen wir über den Einschränkung der Aktionen, die ein Hacker in unserem
Netz unternehmen kann. Die dritte Sektion „Datenaufzeichnung“ stellt Methoden
vor, um im geheimen die Aktivitäten eines Angreifers auf Host- und Netzwerkebene
zu protokollieren. Der „Automatische Alarmierung“ Teil erklärt, wie im Falle
eines erfolgreichen Angriffs sofort die Administratoren benachrichtigt werden
können. Das abschließende Kapitel „Testen“ stellt eine Reihe von Methoden vor,
mit denen man die korrekte Funktionsweise der vorangegangenen Schritte
überprüfen kann. Die Installation, die wir hier beschreiben basiert auf einer
Honeywall die auf Standard x86 Komponenten und einem Linux 2.4 <span
class=SpellE>Kernel</span> läuft. Die Tools und Techniken die in diesem Artikel
vorgestellt werden, sind die, die aktuell von den Mitgliedern des Projektes
genutzt werden. Es ist nicht notwendig, das Sie diese anwenden, nutzen Sie
diejenigen, mit denen Sie am <span class=SpellE>vertrautesten</span> sind.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<h3><u>Die Architektur<o:p></o:p></u></h3>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Ein
Honeynet ist kein Produkt, man installiert es nicht einfach von einer CD und
lässt es ab dann laufen (obwohl wir daran <span class=GramE>arbeiten </span></span><span
style='font-family:Wingdings;mso-ascii-font-family:Arial;mso-hansi-font-family:
Arial;mso-bidi-font-family:Arial;mso-char-type:symbol;mso-symbol-font-family:
Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>J</span></span><span
style='font-family:Arial'>). Ein Honeynet ist eine Architektur, ein vollständig
kontrolliertes Netzwerk, mit dem man Angreifer „in freier Wildbahn“ festhalten
und ihr Vorgehen analysieren kann. Wie Sie diese Architektur aufsetzen, ist
Ihnen überlassen. Um Ihnen bei der Installation zu helfen, haben wir ein Dokument
entwickelt (<a href="http://www.honeynet.org/alliance/requirements.html">Honeynet
Definitionen, Anforderungen und Standards</a>, in Englisch), das Ihnen die
Anforderungen ihres Honeynets umreißt. Es handelt sich nicht um ein technisches
HOWTO, es ist vielmehr eine Sammlung von erprobten und bewährten Methoden wie
man ein Honeynet aufsetzt und von den<span style='mso-spacerun:yes'> 
</span>Mitgliedern der <a href="http://www.honeynet.org/alliance">Honeynet Research
<span class=SpellE>Alliance</span></a> wird erwartet, das sie diese befolgen. Dieser
Artikel stellt einen Weg unter vielen vor, wie man diese Anforderungen erfüllen
kann.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Das
Schlüsselelement eins jeden Honeynets ist das Gateway, die Komponente die das
Honeynet vom Rest der Welt trennt. Dieses Gateway ist wie eine Mauer (darum
nennen wir es auch die Honeywall). Jeglicher Verkehr in das oder aus dem
Honeynet <span class=SpellE>muß</span> durch diese Honeywall hindurch. Sie ist
das Nervenzentrum des Honeynets, hier passieren die Wunder. Für ein GenII
Honeynet ist dieses Gateway eine Layer2-Bridge. Sie können ein Beispiel unserer
angestrebten Honeynetarchitektur in <a
href="http://www.honeynet.org/papers/gen2/figureA.jpg">Abbildung A</a> sehen.
In diesem Beispiel ist unser Honeynet ein 192.168.1.0/24 Netz. In der
Vergangenheit wurden Honeynets üblicherweise mit öffentlichen Adressen oder in
„<span class=SpellE>perimeter</span> <span class=SpellE>Networks</span>“ (wie
übersetzt man das?) aufgesetzt. Durch die Verwendung einer Layer2-Bridge können
wir, wie hier gezeigt, das Honeynet in das interne Netz integrieren. Dadurch
wird es uns möglich, nicht nur Angriffe von außen sondern auch von innen zu
beobachten und daraus zu lernen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>In
der Abbildung ist zu erkennen, <span class=GramE>das</span> die Honeywall (das
Gateway) die produktiven Systeme vom Honeynet (mit den Opferrechnern) trennt.
Die externe Netzwerkkarte (eth0) ist an das Produktivsystem angeschlossen, die
interne Karte (eth1) an das Honeynet. Da es sich um eine Bridge handelt,
befinden sich interne wie externe Systeme auf dem gleichen <span class=SpellE>IP-Netzwerk</span>.
Außerdem gibt es noch eine dritte Netzwerkkarte (eth2), die zur
Fernadministration, einschließlich der Verschiebung von gesammelten Daten an
einen zentralen Ort, der Bridge dient. Die interne und externe Netzwerkkarte
arbeiten im Bridge-Modus, so <span class=GramE>das</span> sie keine <span
class=SpellE>IP-Adresse</span> zugewiesen haben. An die dritte Schnittstelle
(eth2) ist aber ein <span class=SpellE>IP-Stack</span> gebunden, in diesem Fall
hat die Karte die Adresse 10.1.1.1. Bei diesem Netz handelt es sich um ein separates
abgesichertes Netz zu Administrationszwecken. Der Vorteil dieses Aufbaus liegt
darin, das das Gateway nur extrem schwer zu entdecken ist, da es keinen <span
class=SpellE>Hop</span> darstellt, der TTL-Zähler unverändert bleibt und ihm
auch keine <span class=SpellE>MAC-Adresse</span> zugewiesen ist. Außerdem
können wir die Installation des Honeynets durch die Zusammenlegung von
Datenkontrolle und –<span class=SpellE>aufzeichnung</span> auf ein Gerät
vereinfachen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Der
nächste Schritt besteht darin, unser Gateway so aufzusetzen, das es unseren
Anforderungen genügt. Für <span class=GramE>das</span> Gateway kommt eine
gehärtete Minimalinstallation von Linux zum Einsatz. Es ist entscheidend, das
dieses System vertrauenswürdig ist und kein Angreifer Zugriff darauf hat. Als
nächstes müssen wir sicherstellen, das das Gateway <span class=SpellE>Bridging</span>
unterstützt. Die meisten <span class=SpellE>Linuxdistributionen</span>
unterstützen es von Haus aus. Für den Fall das nicht, kann man sich die <span
class=SpellE>Bridging</span> <span class=SpellE>rpms</span> oder die Quelltexte
von <a href="http://bridge.sf.net">http://bridge.sf.net</a> herunterladen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span lang=EN-GB style='font-size:
10.0pt;line-height:150%;font-family:"Courier New";mso-ansi-language:EN-GB'>gateway
#rpm -q bridge-utils<br>
bridge-utils-0.9.3-4<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span lang=EN-GB style='font-size:
10.0pt;line-height:150%;font-family:"Courier New";mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Unglücklicherweise
unterstützen die meisten Distributionen zwar das <span class=SpellE>Bridging</span>
aber nicht IPTables im <span class=SpellE>Bridging-Modus</span>. IPTables ist
aber unverzichtbar, da es nicht nur unser Gateway sichern soll sondern auch zur
Datenkontrolle (wird später erklärt) eingesetzt werden soll. Um IPTables auf
einem Rechner der als Bridge fungiert nutzen zu können, ist es erforderlich den
<span class=SpellE>Kernel</span> zu <span class=SpellE>patchen</span> und
anschließend neu zu kompilieren. Auch diesen <span class=SpellE>Kernelpatch</span>
kann man von <a href="http://bridge.sf.net/">http://bridge.sf.net</a>
herunterladen. Nachdem sichergestellt ist, das das <span class=SpellE>bridging</span>
installiert ist und der <span class=SpellE>Kernel</span> entsprechend <span
class=SpellE>gepatcht</span> ist um IPTables in diesem Modus zu unterstützen
kann man mit der Konfiguration des Gateway beginnen. Das ist wesentlich
einfacher, als es sich anhört. Das Honeynet Project hat das <a
href="http://www.honeynet.org/papers/honeynet/tools/rc.firewall"><span
class=SpellE>rc.firewall</span> Skript</a> entwickelt. Dieses Skript implementiert
fast alle kritischen Punkte des <span class=SpellE>Gateways</span> und wir
werden uns im Laufe dieses Artikels immer wieder darauf beziehen. Auf unserem
Gateway wird das Skript folgendes tun:<o:p></o:p></span></p>

<ul style='margin-top:0cm' type=disc>
 <li class=MsoNormal style='line-height:150%;mso-list:l0 level1 lfo1;
     tab-stops:list 36.0pt'><span class=SpellE><span style='font-family:Arial'>Bridging</span></span><span
     style='font-family:Arial'> aktivieren<o:p></o:p></span></li>
 <li class=MsoNormal style='line-height:150%;mso-list:l0 level1 lfo1;
     tab-stops:list 36.0pt'><span style='font-family:Arial'>Das Gateway mit
     einer Firewall versehen<o:p></o:p></span></li>
 <li class=MsoNormal style='line-height:150%;mso-list:l0 level1 lfo1;
     tab-stops:list 36.0pt'><span style='font-family:Arial'>Die
     Management-Schnittstelle konfigurieren<o:p></o:p></span></li>
 <li class=MsoNormal style='line-height:150%;mso-list:l0 level1 lfo1;
     tab-stops:list 36.0pt'><span style='font-family:Arial'>Festlegen wer wie
     von wo das Gateway administrieren kann<o:p></o:p></span></li>
 <li class=MsoNormal style='line-height:150%;mso-list:l0 level1 lfo1;
     tab-stops:list 36.0pt'><span style='font-family:Arial'>Netzwerkaktivität
     protokollieren<o:p></o:p></span></li>
 <li class=MsoNormal style='line-height:150%;mso-list:l0 level1 lfo1;
     tab-stops:list 36.0pt'><span style='font-family:Arial'>Datenkontrolle
     sicherstellen<o:p></o:p></span></li>
</ul>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Wie
sie sehen, ist dieses Skript extrem wichtig, da es <span class=GramE>das</span>
Gateway so konfiguriert, das es die meisten Anforderungen eines Honeynets
erfüllt. Um dieses Skript lauffähig zu machen (und damit Ihre Honeywall zu
konfigurieren) müssen Sie lediglich die Variablen anpassen und es starten
(Anmerkung: lassen Sie das Skript nicht laufen bevor Sie den gesamten Artikel
gelesen haben). Anstatt jede Variable und ihre Funktion detailliert
vorzustellen gibt es <a href="http://www.honeynet.org/papers/gen2/rc.firewall">hier</a>
ein fertiges Skript, das wir für unsere oben beschriebene Architektur verwendet
haben. Nachdem Sie das Skript für Ihre Architektur <span class=SpellE>angepaßt</span>
haben können Sie zur Datenkontrolle weitergehen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<h3><u>Datenkontrolle<o:p></o:p></u></h3>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Der
Zweck der Datenkontrolle ist es zu verhindern, <span class=GramE>das</span>
Angreifer das Honeynet benutzen um andere Nicht-Honeynet Systeme anzugreifen
oder anders zu schädigen. Datenkontrolle mindert dieses Risiko. Die
Herausforderung ist jedoch folgende: wie viel nach außen gerichtete Aktivität
kann man kontrollieren? Je mehr man dem Angreifer gestattet zu tun, desto mehr
kann man lernen. Allerdings gilt auch: je mehr man dem Angreifer gestattet zu
tun, desto mehr Schaden können sie auf anderen Systemen anrichten. Also <span
class=SpellE>muß</span> man ihre Aktivitäten genug kontrollieren um Schaden für
andere zu verhindern aber nicht zu sehr, sonst kann man nichts lernen. Wie viel
Freiheit man einem Angreifer zugesteht, hängt also von dem Risiko ab, das man bereit
ist einzugehen. Eine zusätzliche Herausforderung besteht darin, den Angreifer
zu kontrollieren ohne <span class=GramE>das</span> er die Kontrolle bemerkt. Um
diese Punkte zu erfüllen, werden wir zwei Techniken verwenden: Verbindungen
zählen und NIPS. Verbindungen zählen bedeutet, <span class=GramE>das</span> man
die Zahl der ausgehenden Verbindungen, die ein Honigtopf aufbauen kann,
beschränkt. NIPS (<span class=SpellE>Network</span> <span class=SpellE>Intrusion</span>
<span class=SpellE>Prevention</span> System) kann bekannte Angriffe blockieren
oder außer Gefecht setzen. Kombiniert man diese beiden hat man einen mächtigen
und flexiblen Mechanismus zur Datenkontrolle. Wir werden beide auf unserem
Layer2 Gateway einsetzen. Die Datenkontrolle wird hier angesetzt, da dies der
Punkt ist, wo jeglicher Verkehr hindurch <span class=SpellE>muß</span>.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Nachdem
Sie ihr Gateway wie oben beschrieben konfiguriert <span class=GramE>haben</span>,
folgt als nächster Schritt die Einschränkung der Verbindungen. Wir
kontrollieren, wie viele Verbindungen ein Angreifer von unserem Honigtopf aus
initiieren kann und blockieren beim Erreichen eines bestimmten Limits weitere
Versuche. Für diese Aufgabe verwenden wir IPTables, das durch das <span
class=SpellE>rc.firewall</span> Skript installiert und konfiguriert sein
sollte. Im Skript kann man festlegen wie viele TCP, UDP, ICMP oder OTHER
Verbindungen nach draußen aufgebaut werden dürfen. Wie viele das sind hängt von
Ihrer Risikobereitschaft ab. Das Honeynet Project erlaubt durchschnittlich
15-30 Verbindungen pro Tag. Diese Einschränkung hindert den Angreifer daran,
vom Honeynet aus eine Vielzahl von Systemen zu scannen, anzugreifen oder <span
class=SpellE>Denial-of-Service</span> (<span class=SpellE>DoS</span>) Angriffe
zu starten. Es ist schwierig Schaden anzurichten, wenn man in der Anzahl seiner
Verbindungen eingeschränkt ist. Die Standardeinstellungen im Skript sind wie
folgt. Beachten Sie, das die Variable OTHER jedes <span class=SpellE>IP-Protokoll</span>
umfasst, das NICHT TCP, UDP oder ICMP ist (also zum Beispiel <span
class=SpellE>IPsec</span>, <span class=SpellE>getunneltes</span> IPv6, <span
class=SpellE>Network</span> <span class=SpellE>Voice</span> <span class=SpellE>Protocol</span>
usw.)<o:p></o:p></span></p>

<p><span lang=EN-GB style='font-size:10.0pt;font-family:"Courier New";
mso-ansi-language:EN-GB'>### Set the connection outbound limits for different
protocols.<br>
SCALE=&quot;day&quot;<br>
TCPRATE=&quot;15&quot;<br>
UDPRATE=&quot;20&quot;<br>
ICMPRATE=&quot;50&quot;<br>
OTHERRATE=&quot;15&quot;</span><span lang=EN-GB style='font-size:10.0pt;
font-family:Arial;mso-ansi-language:EN-GB'><o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Auf
diese Weise implementiert IPTables die Verbindungseinschränkung. Wenn ein
Angreifer in einen Honigtopf einbricht, gibt es verschiedene Gründe
Verbindungen nach außen aufzubauen (<span class=SpellE>Toolkits</span>
herunterladen, automatische <span class=SpellE>Bots</span>, IRC <span
class=SpellE>chats</span>, <span class=SpellE>emails</span> versenden usw.).
Wird eine solche Verbindung aufgebaut, zählt die Firewall sie. Wird das Limit
erreicht, blockiert IPTables jede weitere Verbindung von diesem Honigtopf.
Danach setzt sich IPTables zurück und erlaubt von da an so viele Verbindungen
pro Zeiteinheit wie vorgegeben. Nehmen wir zum Beispiel an, das TCP Limit läge
bei 25 Verbindungen pro Tag. Bricht jemand in den Honigtopf ein, stehen ihm 25
Verbindungen frei. Erreicht er dieses Limit, kann er keine mehr starten.
IPTables wird dann zurückgesetzt und erlaubt ab dann nur noch 25 Verbindungen
in dem angegebenen Zeitraum (hier: 24 Stunden). Das heißt pro Stunde kommt eine
Verbindung zustande. Wäre der Zeitraum nicht ein Tag sondern z.B. eine Stunde
gewesen, so hätte der Angreifer pro Stunde 25 Verbindungen starten können (d.h.
alle 144 Sekunden eine). Wie so etwas in Wirklichkeit aussieht kann man <a
href="http://www.honeynet.org/papers/gen2/win2000.txt">hier</a> anhand einer IPTables
Protokolldatei sehen. Es handelt sich um einen Windows2000 Honigtopf der mit
dem Code Red II Wurm infiziert ist und jetzt versucht weitere Opfer zu finden. Eine
nette Fähigkeit von IPTables ist es die Limits getrennt zu verwalten, d.h. ist
das TCP Limit erreicht hat das keinen <span class=SpellE>Einfluß</span> auf
UDP, ICMP oder OTHER , es sei denn, auch deren Limits wären erreicht.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Nachdem
die Verbindungsbeschränkung mit Hilfe des <span class=SpellE>rc.firewall</span>
Skriptes aufgesetzt ist, folgt als nächstes die Implementierung der NIPS
Funktionen. Die Aufgabe von NIPS ist es, bekannte Angriffe zu erkennen und zu
blockieren. Dies wird erreicht, indem jedes einzelne Paket auf seinem Weg durch
<span class=GramE>das</span> Gateway untersucht wird. Erfüllt ein Paket die IDS
Regeln wird nicht nur ein Alarm generiert<span style='mso-spacerun:yes'> 
</span>(wie bei einem traditionellen NIDS) sondern man kann auch festlegen ob
das Paket verworfen (und die Attacke dadurch blockiert) oder verändert werden
soll (macht die Attacke wirkungslos). Der Vorteil hier ist das dramatisch
gesunkene Risiko eines erfolgreichen Angriffs. Im Fall der
Verbindungsbeschränkung erlauben wir standardmäßig 15 ausgehende Verbindungen
pro Tag. Aber was passiert wenn das Honeynet durch einen Wurm infiziert wird, der
versucht in diesen ersten 15 Verbindungsversuchen andere Systeme zu befallen?
Die Einschränkung reduziert zwar die Zahl der Systeme die er infizieren kann,
aber das Risiko bleibt. Die Idee hinter einem NIPS ist, diese Attacken zu
erkennen und zu blockieren oder außer Gefecht zu setzen. Zu diesem Zweck nutzt
das Honeynet Project <a href="http://www.honeynet.org/papers/honeynet/tools/">Snort_inline</a>,
eine modifizierte Version von <span class=SpellE>Snort</span>, die Pakete verwerfen
oder modifizieren kann.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Damit
snort_inline als ein NIPS fungieren kann, braucht es jemanden der für ihn das <span
class=SpellE>routing</span> übernimmt, da snort_inline nicht weiß wie es als
Router (<span class=SpellE>ip_forward</span>) arbeiten soll. Also brauchen wir
jemanden, der die Pakete für snort_inline <span class=SpellE>routet</span> und
während des <span class=SpellE>Routingprozesses</span> <a
href="http://www.honeynet.org/papers/honeynet/tools/"></a>die Pakete an
snort_inline zur Analyse übergibt. Sobald snort_inline die Analyse beendet hat
reicht es die Pakete an den <span class=SpellE>Routingprozess</span> zurück.
Dieser Prozess ist IPTables. Wir konfigurieren IPTables so, das es Pakete vor
der Weiterleitung zur Analyse durch snort_inline in den <span class=SpellE>user</span>
<span class=SpellE>space</span> übergibt und anschließend weiterleitet. Diese
Fähigkeit von IPTables heißt „<span class=SpellE>user</span> <span
class=SpellE>space</span> <span class=SpellE>queuing</span>“ und setzt voraus,
das das <span class=SpellE>ip_queue</span> Modul in den <span class=SpellE>Kernel</span>
geladen ist. Um diese Fähigkeit zu aktivieren <span class=SpellE>muß</span> lediglich
die Option QUEUE im <span class=SpellE>rc.firewall</span> Skript gesetzt werden
(das daraufhin auch das <span class=SpellE>Kernelmodul</span> <span
class=SpellE>ip_queue</span> aktiviert). Etwas sollte man allerdings beachten,
wenn man snort_inline und die Fähigkeit Verbindungen zu zählen von IPTables einsetzt:
IPTables zählt die Verbindung unabhängig davon, ob snort_inline das Paket
durchlässt oder nicht. Dieses Benehmen kommt daher, da alle Pakete bereits die
interne Netzwerkkarte passiert haben bevor snort_inline sie analysieren kann.
Die Verbindung wurde also schon gezählt, bevor snort_inline sie überhaupt
sieht.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<pre><span lang=EN-GB style='mso-ansi-language:EN-GB'>### IPTables script can be used with the Snort-Inline filter<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>#QUEUE=&quot;no&quot;<span style='mso-spacerun:yes'>              </span># Do not use experimental QUEUE support<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>QUEUE=&quot;yes&quot;<span style='mso-spacerun:yes'>              </span># Use experimental QUEUE support<o:p></o:p></span></pre>

<p class=MsoNormal style='line-height:150%'><span lang=EN-GB style='font-family:
Arial;mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Zu
Ihrer Information: wenn Sie die snort_inline Fähigkeiten aktivieren, dann
MÜSSEN Sie snort_inline laufen haben. Wenn nicht, oder wenn snort_inline aus
irgendeinem Grund stirbt, werden keine Pakete durch <span class=SpellE>IPTables</span>
<span class=SpellE>geroutet</span> (dies ist kein Fehler, sondern dient der
Sicherheit). Deswegen ist unser nächster Schritt das Konfigurieren von
snort_inline. Es ähnelt sehr stark dem von <span class=SpellE>snort</span>, es
nutzt nur einen anderen Regelsatz. Denken Sie daran: es ist nicht unser Ziel,
allen ausgehenden Verkehr zu verbieten, sondern nur Angriffe. Wir möchten also
ein Regelwerk, das nur tatsächliche Angriffe oder <span class=SpellE>Exploits</span>
behandelt. Ausgehende Anfragen wie zum Beispiel ein ICMP <span class=SpellE>Ping</span>,
ein <span class=SpellE>finger</span> oder ein einfaches http GET Kommando
sollen nicht geblockt werden. Wenn wir alle <span class=SpellE>snort-Regeln</span>
eintragen, kann der Angreifer nichts nach außen gerichtetes unternehmen. Daher
nutzen wir also nur die Regeln, die tatsächlich Angriffe beschreiben. Jede
Organisation wird wahrscheinlich andere Definition von „Angriff“ haben, daher empfehlen
wir, die snort_inline Regeln durchzusehen und gegebenenfalls anzupassen, bevor
man sie verwendet. Unser Regelwerk <span class=SpellE>muß</span> außerdem die
Umkehrung eines typischen <span class=SpellE>snort-Regelwerks</span> sein, da
diese sich auf eingehende Attacken konzentrieren, wohingegen wir nach
ausgehenden Attacken suchen. Das Ziel ist es, den Rest der Welt vor dem
Honeynet zu schützen. Der letzte Unterschied besteht darin, <span class=GramE>das</span>
wir bei Aktivität keine Alarme auslösen, sondern Angriffe blockieren oder
modifizieren wollen. Um diesen Prozess zu vereinfachen, hat das Honeynet
Projekt zwei Regelwerke geschaffen, die man zu diesem Zweck einsetzen kann. Das
erste ist das <a href="http://www.honeynet.org/papers/gen2/figureB.gif"><span
class=SpellE>drop-rules.tgz</span></a>. Es dient zum Analysieren von ausgehenden
Paketen und wirft bei Erkennen eines Angriffs das betroffene Paket weg oder blockiert
es. Was genau geschieht, kann man sich an dem zuvor erwähnten Beispiel einer verworfenen
<a href="http://www.honeynet.org/papers/gen2/cr2.txt">Code Red II</a> Attacke
ansehen. Das zweite Regelwerk nennen wir das <a
href="http://www.honeynet.org/papers/gen2/figureC.gif"><span class=SpellE>replace-rules</span></a>
Regelwerk. Dieses Regelwerk blockiert keine Angriffe, sondern verändert den
Inhalt der eigentlichen Attacke auf Paketebene und lässt sie so ins Leere
laufen. Diese Art von Kontrolle ist für den Angreifer wahrscheinlich noch
schwerer zu entdecken. Sie können sehen wie ihre Angriffe die angepeilten Ziele
erreichen, aber nicht erklären, warum sie keine Wirkung zeigen. Die <span
class=SpellE>drop-rules</span> finden Sie in der <a
href="http://www.honeynet.org/papers/honeynet/tools/">Honeynet Tools <span
class=SpellE>Section</span></a>. An den <span class=SpellE>replace-rules</span>
arbeitet das Projekt <span class=GramE>zur Zeit</span>.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Bei
unserer Installation werden wir das „<span class=SpellE>drop-rules</span>“
Regelwerk und die <br>
<span class=SpellE>snort_inline.conf</span> Konfigurationsdatei im Verzeichnis
/etc/ snort_inline installieren. Wir nehmen ein anderes Verzeichnis als /etc/<span
class=SpellE>snort</span> um nicht mit den beiden Versionen <span class=SpellE>durcheinanderzukommen</span>.
Um snort_inline zu starten, rufen wir das <a
href="http://www.honeynet.org/papers/honeynet/tools/snort_inline.sh">snort_inline
<span class=SpellE>startskript</span></a> auf. Dieses Skript ist mit allen
nötigen Werten vorkonfiguriert um snort_inline korrekt zum Laufen zu bekommen.
Um das Leben viel einfacher zu machen, gibt es alle snort_inline
Konfigurationsdateien, Regeln, Startskripte und sogar eine vorkompilierte
Binärdatei zusammen als <a
href="http://www.honeynet.org/papers/honeynet/tools/snort_inline.tgz">Honeynet
snort_inline <span class=SpellE>Toolkit</span></a>. Durch das Verwenden dieses
Paketes sollte die Installation von snort_inline wesentlich einfacher werden.
Vergessen Sie nicht: die Kombination dieser Technologien kann helfen das Risiko
dramatisch zu reduzieren, aber eliminieren kann es das Risiko nicht. Immer wenn
man Hacker zu sich einlädt, kann etwas schief gehen. Das ist der Grund, warum
wir im letzten Kapitel erklären, wie man seine Umgebung testet. Aber selbst
dann kann man nicht absolut sicher ein, da die Angreifer ständig neue Methoden
und Vorgehensweisen entwickeln.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<h3><u>Datensammlung<o:p></o:p></u></h3>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Nachdem
wir die Datenkontrolle sichergestellt haben, geht es jetzt an das Aufsetzen der
Datensammlung. Ihr Zweck besteht darin, jede Aktivität des Angreifers zu protokollieren.
Eigentlich ist das Sinn des gesamten Honeynets: Daten zu sammeln. Ohne das ist
unser Honeynet wertlos. Der Trick bei der Datensammlung ist es, in so vielen
Schichten wie möglich zu sammeln. Eine einzige Schicht verrät niemals alles.
Ein Beispiel: viele Leute meinen, es reiche doch aus die Tastatureingaben des
Angreifers zu kennen. Gut, aber was geschieht, wenn er ein Tool startet? Wie
will man wissen, was dieses Tool macht, wenn man es nicht abfängt oder
zumindest den von ihm generierten Netzwerkverkehr? Das Honeynet Projekt hat
drei kritische Punkte zum Sammeln definiert: <span class=SpellE>Firewallprotokolle</span>,
Netzwerkverkehr und Systemaktivität. Wir werden ausführlich erklären, wie man
alle drei implementiert.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span class=SpellE><span
style='font-family:Arial'>Firewallprotokolle</span></span><span
style='font-family:Arial'> sind recht einfach und schon behandelt worden. Durch
den Einsatz des <span class=SpellE>rc.firewalls</span> Skripts protokollieren
wir bereits alle ein- und ausgehenden Verbindungen in /<span class=SpellE>var</span>/log/<span
class=SpellE>messages</span>. Diese Informationen sind wichtig, da sie den
ersten Anhaltspunkt darstellen, was unser Angreifer macht. Sie sind außerdem
die erste Warnung, <span class=GramE>das</span> ein ausgehender Angriff
beginnt. Die Erfahrungen aus dem Projekt haben gezeigt, das die Protokolle wichtig
für die schnelle Erkennung von neuen oder unbekannten Vorgängen sind. Das
Skript identifiziert vier verschiedene Arten von Verkehr: TCP, UDP, ICMP und
OTHER. Wie bei der Datenkontrolle steht OTHER für jeden Verkehr, der nicht vom
Typ 1, 6 oder 17 ist. Außerdem ist es wahrscheinlich sowieso das
interessanteste, denn jemand der nicht <span class=SpellE>Standard-IP</span>
Protokolle nutzt, wird sehr wahrscheinlich eine neue Attacke oder Methode
ausprobieren, die bislang unbekannt war (wie bei der Hintertür im <a
href="http://www.honeynet.org/scans/scan22/"><span class=SpellE>Scan</span> des
Monats 22</a>).<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Die
zweite Schicht ist das Abfangen jedes Paketes im Ganzen, wenn es das Honeynet
betritt oder verlässt. Dies könnte zwar der snort_inline <span class=SpellE>Prozeß</span>
erledigen, allerdings wollen wir uns nicht zu sehr auf eine Alternative
stützen. Stattdessen wollen wir einen zweiten <span class=SpellE>Prozeß</span>
starten und so konfigurieren, <span class=GramE>das</span> er alle Aktivitäten
protokolliert. Dies lässt sich durch die Standard <a
href="http://www.honeynet.org/papers/honeynet/tools/snort.conf">snort_inline
Konfigurationsdatei</a> des Projekts erreichen. Diese Datei schreibt den
gesamten <span class=SpellE>IP-Verkehr</span> zur weiteren Analyse in eine <span
class=SpellE>tcpdump-Datei</span>. Diese Dateien sollen außerdem täglich
rotieren. Dafür verwenden wir das <a
href="http://www.honeynet.org/papers/honeynet/tools/snort.sh"><span
class=SpellE>snort.sh</span> Startskript</a>. Dieses Startskript wird täglich
von <span class=SpellE>cron</span> gestartet. Beachten sie, <span class=GramE>das</span>
wir in dem Skript den <span class=SpellE>Sniffer</span> an die interne
Netzwerkkarte eth1 binden. Das ist wichtig! Sollten sie aus Versehen den <span
class=SpellE>Sniffer</span> an die externe Karte eth0 binden, so schneiden sie
nicht nur Daten aus dem Honeynet mit, sondern den ganzen Verkehr der zu dem
externen Netz gehört. Dadurch<span style='mso-spacerun:yes'>  </span>werden die
Daten nahezu unbrauchbar. Durch das Verwenden der internen Karte fängt man nur
den Verkehr in das und aus dem Honeynet ab: genauso, wie es sein soll. Ein
weiterer Vorteil des Skriptes ist es, das man einen Standard für die Ablage der
Protokolldateien hat, was sehr wichtig wird, wenn man mehrere Honeynets hat,
die alle zu einem zentralen Punkt protokollieren (dazu später mehr).<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Der
dritte und am schwierigsten zu realisierende Punkt ist das Aufzeichnen der Aktivitäten
des Hackers am System selbst. Vor einigen Jahren war das noch einfach, da die
meisten Fernzugriffe über Klartext-Protokolle wie FTP, http oder <span
class=SpellE>telnet</span> erfolgten. Man musste lediglich die Verbindung
belauschen, um die Tastatureingaben abzufangen. Heute jedoch haben die Bösen
die Verschlüsselung entdeckt. Sie verwenden SSH oder 3DES verschlüsselte Tunnel
um mit den kompromittierten Systemen zu kommunizieren. Also kann man heute
nicht mehr die Tastatureingaben am Kabel belauschen, sondern nur an der
Maschine selbst. Das Honeynet Projekt hat dazu Sebek2 entwickelt. Sebek2 ist
ein <span class=SpellE>Kernelmodul</span>, das in der Lage ist, Tastatureingaben
zu protokollieren und Dateien abzufangen, die per <span class=SpellE><i
style='mso-bidi-font-style:normal'>secure</i></span><i style='mso-bidi-font-style:
normal'> <span class=SpellE>copy</span></i> (<span class=SpellE>scp</span>)
kopiert werden. Einmal installiert macht es sich unsichtbar und dadurch nahezu
unmöglich, es aufzuspüren und zu entladen. Die Informationen die Sebek2 sammelt
werden nicht auf dem Honigtopf, wo der Angreifer sie entdecken kann,
gespeichert. <span class=GramE>Statt dessen</span> werden sie per UDP an eine
Überwachungsmaschine (wie z.B. das lokale <span class=SpellE>Gateway</span>
oder eine entfernte Maschine in einem anderen Netzwerk) gesandt. Angreifer
können diese Pakete weder sehen noch abhören, da das <span class=SpellE>Kernelmodul</span>
sie verbirgt. Auch wenn der Angreifer seine eigenen Überwachungstools nutzt
oder <span class=SpellE>herunterlädt</span>, bleibt die Aktivität von Sebek2
ihm verborgen. Dies wird erreicht, indem man den Honigtopf so verändert, das er
Pakete mit einer vorgegebenen <span class=SpellE>MAC-Adresse</span> weder sehen
noch mitschneiden kann. Sebek2 schickt dann einfach seine Daten mit dieser <span
class=SpellE>MAC-Adresse</span> auf den Weg, wo sie dann von dem <span
class=SpellE>Gateway</span> abgefangen werden. Da alle Honigtöpfe von Sebek2
kontrolliert werden kann keiner von ihnen genutzt werden um die Aktivitäten zu
belauschen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Anmerkung:
wenn es in ihrem Honeynet einen Honigtopf ohne Sebek2 gibt und der Angreifer
erlangt Kontrolle über ihn, kann er alle Sebek2-Pakete von anderen Systemen
belauschen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Da
es sich bei Sebek2 um ein <span class=SpellE>Kernelmodul</span> handelt, <span
class=SpellE>muß</span> es passend für das jeweilige OS und die <span
class=SpellE>Kernelversion</span> kompiliert werden. Die Installation von
Sebek2 ist problemlos, da es lediglich fünf Optionen im Installationsskript
gibt. Wir installieren so, wie unten gezeigt, d.h. belauschte Tastatureingaben
werden in <span class=SpellE>UDP-Pakete</span> verpackt und an die <span
class=SpellE>IP-Adresse</span> 192.168.1.254 (den Router) mit dem Zielport
34557 verschickt. Unser Angreifer wird diese Pakete jedoch nie zu sehen
bekommen, da der <span class=SpellE>Kernel</span> alle Pakete mit einer SRC MAC
Adresse von 0A:0B:0C versteckt (Sebek2 wertet nur die ersten drei der sechs
Oktette der MAC Adresse aus). Diese Einstellungen sollten auf allen Honigtöpfen
vorgenommen werden, damit sie sich nicht gegenseitig sehen können. Diese Pakete
kommen nicht tatsächlich am Router an, da <span class=GramE>das</span> <span
class=SpellE>Gateway</span> sie blockt (und protokolliert). Alle Optionen sind
anpassbar an die Bedingungen und die Vorgaben ihres eigenen Honeynets. Wenn sie
zum Beispiel die Pakete an ein System in einem anderen Netz schicken möchten,
tragen sie die <span class=SpellE>IP-Adresse</span> des Zielsystems und die Ziel
<span class=SpellE>MAC-Adresse</span> des lokalen <span class=SpellE>Routers</span>
ein. Passen sie auf, das sie das <span class=SpellE><i style='mso-bidi-font-style:
normal'>sebek.sh</i></span> Installationsskript, das dem <span class=SpellE>Sourcecode</span>
beiliegt verwenden, da dieses Skript außer der <span class=SpellE>sebek</span>
Installation auch noch ein Modul installiert um die Gegenwart von <span
class=SpellE>sebek</span> zu verbergen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<pre><span lang=EN-GB style='mso-ansi-language:EN-GB'>#----- sets destination IP for <span
class=SpellE>sebek</span> packets<o:p></o:p></span></pre><pre><span lang=EN-GB
style='mso-ansi-language:EN-GB'>DESTINATION_IP=&quot;192.168.1.254&quot;<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>#----- sets destination MAC <span
class=SpellE>addr</span> for <span class=SpellE>sebek</span> packets<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>DESTINATION_MAC=&quot;</span><st1:time
Hour="0" Minute="1"><span lang=EN-GB style='mso-ansi-language:EN-GB'>00:01</span></st1:time><span
lang=EN-GB style='mso-ansi-language:EN-GB'>:C9:F6:D3:59&quot;<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>#----- defines the destination <span
class=SpellE>udp</span> port <span class=SpellE>sebek</span> sends to<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>DESTINATION_PORT=34557<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>#----- controls what SRC MAC <span
class=SpellE>OUIs</span> to hide from users<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>#----- Only the first 3 octets are evaluated.<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>FILTER_OUI=&quot;0A:0B:0C&quot;<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>#----- controls the output interface<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>INTERFACE=&quot;eth0&quot;;<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='line-height:150%'><span lang=EN-GB style='font-family:
Arial;mso-ansi-language:EN-GB'><span style='mso-spacerun:yes'> </span><o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Einmal
konfiguriert und gestartet, protokolliert Sebek2 die gesamte Systemaktivität
ins Netz. Diese Pakete, die von dem Honigtopf weder gesehen noch belauscht werden
können, werden passiv am <span class=SpellE>Gateway</span> an der internen
Schnittstelle eth0 gesammelt. Diese Pakete werden dann verwendet um Eingaben
oder Dateien die der Angreifer <span class=SpellE>heruntergeladen</span> hat zu
rekonstruieren. Unser Honeynet hat einen zusätzlichen Vorteil. Da wir eine
eigene Schnittstelle zur Administration haben, kann unser Honeynet automatisch
protokollierte Daten an eine zentrale Stelle <span class=SpellE>hochladen</span>.
Dies kann extrem nützlich sein, wenn sie mehrere Honeynets betreuen. Durch die
Kombination der Daten aus verschiedenen Honeynets lassen sich Frühwarnungen,
Vorhersagen und statistische Analysen gewinnen oder neue Werkzeuge und Trends
identifizieren. Das Honeynet Projekt benutzt dieses <a
href="http://www.honeynet.org/papers/honeynet/tools/linux-upload.sh">Skript</a>
um die Daten täglich automatisch <span class=SpellE>hochzuladen</span>. Das
Honeynet Projekt portiert Sebek2 gegenwärtig auf Solaris, <span class=SpellE>OpenBSD</span>
und Win32. <o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<h3><u>Alarmierung<o:p></o:p></u></h3>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Es
gibt noch einen letzten Punkt, der bedacht werden will, bevor man sein Honeynet
fertig stellt: automatisierte Alarmierung. Wenn jemand in das eigene Honeynet
einbricht ist das eine großartige Gelegenheit, etwas zu lernen. Jedenfalls wenn
man mitbekommt, das jemand da ist. Das der Administrator über einen
erfolgreichen Einbruchsversuch informiert wird ist von entscheidender Wichtigkeit
für ein Honeynet. Idealerweise hätte man natürlich eine <span class=SpellE>Rund-um-die-Uhr</span>
Betreuung durch einen erfahrenen Administrator. Mit einem entsprechend konfigurierten
Programm ist das aber nicht nötig. Wir haben in der Überwachung unserer
Honeynets mit <a href="http://swatch.sourceforge.net/">Swatch</a> (Simple <span
class=SpellE>Watcher</span>) große Erfolge gehabt. Swatch ist en komplett
ausgestattetes automatisches Überwachungswerkzeug, das in der Lage ist <span
class=SpellE>Admins</span> über potentiell erfolgreiche Einbruchsversuche zu
informieren. Swatch überwacht Protokolldateien auf bekannte Muster, die in
einer Konfigurationsdatei beschrieben werden. Findet es ein solches Muster,
kann es selbstständig Alarme per <span class=SpellE>email</span>, Telefon oder
systemeigene Mechanismen auslösen und darüber hinaus andere Programme/Befehle
ausführen. Eine einfache Swatch Regel enthält das zu überwachende Muster,
gefolgt von einer Liste von zu startenden Aktionen. Das folgende Beispiel
basiert auf Swatch 3.0:<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<pre><span class=SpellE><span class=GramE><span lang=EN-GB style='mso-ansi-language:
EN-GB'>watchfor</span></span></span><span lang=EN-GB style='mso-ansi-language:
EN-GB'> /Firewall:<span style='mso-spacerun:yes'>  </span>OUTBOUND CONNECTION/<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'><span style='mso-spacerun:yes'>     </span><span
class=GramE>echo</span> normal<o:p></o:p></span></pre><pre><span lang=EN-GB
style='mso-ansi-language:EN-GB'><span style='mso-spacerun:yes'>     </span></span><span
class=SpellE>mail=admin@honeynet.org,subject</span>=------ ALERT! OUTBOUND CONN --------</pre><pre><span style='mso-spacerun:yes'>     </span><span
class=SpellE>throttle</span> 10:0:0</pre>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Die
„<span class=SpellE>mail</span>=“ Aktion enthält eine Liste von Adressen, an
die der Alarm zu schicken ist, während der „<span class=SpellE>throttle</span>“
Befehl einschränkt, wie oft die Aktion für diese Regel pro <span class=SpellE>Stunde:Minute:Sekunde</span>
ausgeführt werden darf (sehr nützlich um überfüllte Mailboxen zu vermeiden,
wenn ein Alarm ausgelöst wird). Das obige Beispiel überwacht /<span
class=SpellE>var</span>/log/<span class=SpellE>messages</span>, wohin <span
class=SpellE>IPTables</span> alle ein- und ausgehenden Verbindungen protokolliert.
Es sucht nach ausgehenden Verbindungen, ein sehr guter Indikator dafür, dass
das Honeynet kompromittiert worden ist. Bei Übereinstimmung mit dem gesuchten
Muster, wird eine E-Mail an den Honeynet Administrator geschickt. Allerdings
ist die Häufigkeit solcher Mails in diesem Beispiel auf zehn pro Stunde
begrenzt. Die überwachten Muster und die unternommenen Aktionen unterscheiden
sich natürlich zwischen den einzelnen Honeynet Installationen. Wesentlich
wichtiger als die Feinheiten der Swatch-Konfigurationsdatei ist ein Verständnis
dafür, auf welche Ereignisse im Honeynet ein Administrator achten <span
class=SpellE>muß</span> und welche Informationen ein Alarm liefern sollte. Die
besten Quellen für Informationen über feindliche Aktivitäten sind die Firewall-
und snort_inline Protokolle.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Von
der Firewall:<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Ausgehende
Verbindungen von einem Honigtopf sind gute Hinweise darauf, <span class=SpellE>daß</span>
die Maschine kompromittiert wurde. Da es keine Benutzer in einem Honeynet gibt,
ist Verkehr, der das Honeynet verlassen will sehr wahrscheinlich von einem
Eindringling. Es mag von Zeit zu Zeit Fehlalarme geben (z.B. wenn der <span
class=SpellE>ftp-Server</span> eine ausgehende <span class=SpellE>Ident-Verbindung</span>
aufbaut), aber generell ist dies der beste Indikator für eine Kompromittierung
und potentiell bösartige Aktivitäten. Sie sollten vielleicht Alarme über
ausgehende Verbindungen nicht einschränken, da die Zahl der erhaltenen <br>
Alarme selbst ein Hinweis auf die Art von Aktivität des Angreifers sein kann.
Eine andere Möglichkeit wäre es, die <span class=SpellE>Firewall-Protokolle</span>
auf Einträge von Sebek2 zu<br>
überwachen. Sebek2-Pakete sind ganz hervorragend geeignet, um die Anwesenheit
von jemandem festzustellen und werden von der Firewall protokolliert.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Vom
NIPS:<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Wie
schon besprochen ist es die Aufgabe des NIPS (wir nutzen snort_inline) ausgehende
Angriffe aufzuspüren und zu blocken. Sie sollten ihren Alarmmechanismus (z.B.
Swatch) vielleicht so konfigurieren, das er nicht nur <span class=SpellE>Firewall-Protokolle</span>
sondern auch snort_inline Alarme überwacht. Wenn ein Angriff entdeckt (und
geblockt) wird, möchten Sie das sofort und unverzüglich wissen.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Das
Ziel einer automatisierten Alarmierung ist es, die Administratoren mit so vielen
Informationen zu versorgen, das sie auf einen erfolgreichen Angriff reagieren
können. Jeder Alarm den Swatch auslöst sollte als Minimum folgendes enthalten:
die Quell- und Zieladresse sowie den Port des abgefangenen Paketes, Datum und
Uhrzeit an denen das Ereignis stattgefunden hat und genug Informationen, damit
der Administrator sofort aktiv werden kann. Standardmäßig schließt Swatch die
Zeile aus dem Protokoll ein, die auf die Regel passte. Ein Beispielalarm für
die obige Regel sähe in etwa so aus:<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<pre><span lang=EN-GB style='mso-ansi-language:EN-GB'>To:<span style='mso-spacerun:yes'>  </span>admin@honeynet.org<o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>From:<span style='mso-spacerun:yes'>  </span>yourdatacontrol@yourdomain.org<span style='mso-spacerun:yes'>                                    </span><span style='mso-spacerun:yes'>                                                           </span><o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>Subject:<span style='mso-spacerun:yes'>  </span>------ ALERT<span
class=GramE>!:</span> OUTBOUND </span><st1:State><st1:place><span lang=EN-GB
  style='mso-ansi-language:EN-GB'>CONN</span></st1:place></st1:State><span
lang=EN-GB style='mso-ansi-language:EN-GB'> --------<span style='mso-spacerun:yes'>                                                                                          </span><o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'><span style='mso-spacerun:yes'>                                                          </span><span style='mso-spacerun:yes'>                                                                          </span><o:p></o:p></span></pre><pre><span
class=GramE><span lang=EN-GB style='mso-ansi-language:EN-GB'>Apr<span style='mso-spacerun:yes'>  </span>6</span></span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> </span><st1:time Minute="19"
Hour="17"><span lang=EN-GB style='mso-ansi-language:EN-GB'>17:19:05</span></st1:time><span
lang=EN-GB style='mso-ansi-language:EN-GB'> <span class=SpellE>honeywall</span> FIREWALL:OUTBOUND CONN UDP:IN=br0<span style='mso-spacerun:yes'>                                                                        </span><o:p></o:p></span></pre><pre><span
lang=EN-GB style='mso-ansi-language:EN-GB'>PHYSIN=eth1 OUT=br0 PHYSOUT=eth2 SRC=192.168.1.101<o:p></o:p></span></pre><pre>DST=63.107.222.112 LEN=123 TOS=0x00 PREC=0x00 TTL=255 ID=43147</pre><pre>PROTO=UDP SPT=5353 DPT=79 LEN=103<span style='mso-spacerun:yes'>  </span></pre>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Sogar
mit den Tools die im Abschnitt über Datenkontrolle vorgestellt wurden erfordert
ein Honeynet ständige Überwachung. Korrekt konfiguriert kann Swatch dazu
dienen, Administratoren schnell über Vorgänge in ihrem Netzwerk zu informieren.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<h3><u>Testen<o:p></o:p></u></h3>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Nachdem
wir Datenkontrolle und Datensammlung konfiguriert haben, ist der nächste
Schritt das Testen des <span class=SpellE>Gateways</span>. Für die Tests
brauchen wir ein System mit einer externen Netzwerkschnittstelle. Ausgehend von
<a href="http://www.honeynet.org/papers/gen2/figureA.jpg">Abbildung A</a>
nehmen wir die 192.168.1.20 als Testsystem. Wir fangen mit der Datenkontrolle
an: erfasst unser Honeynet erfolgreich ein- und ausgehende Verbindungen? Also
stellen wir vom Testsystem aus eine Verbindung zu einem der Honigtöpfe
innerhalb des Honeynets her. Basierend auf ihrem Regelwerk sollte die
Verbindung erlaubt worden sein. Wenn die Verbindung funktioniert hat, sollte
sich in /<span class=SpellE>var</span>/log/<span class=SpellE>messages</span> ein
Eintrag ähnlich diesem finden:<o:p></o:p></span></p>

<p><span lang=EN-GB style='font-size:10.0pt;font-family:"Courier New";
mso-ansi-language:EN-GB'>Mar 23 </span><st1:time Minute="55" Hour="20"><span
 lang=EN-GB style='font-size:10.0pt;font-family:"Courier New";mso-ansi-language:
 EN-GB'>20:55:09</span></st1:time><span lang=EN-GB style='font-size:10.0pt;
font-family:"Courier New";mso-ansi-language:EN-GB'> <span class=SpellE>honeywall</span>
kernel: INBOUND TCP: IN=br0 PHYSIN=eth0 OUT=br0 PHYSOUT=eth1 SRC=192.168.1.20
DST=192.168.1.101 LEN=60 TOS=0x00 PREC=0x00 TTL=63 ID=48699 DF PROTO=TCP
SPT=36797 DPT=21 WINDOW=5840 RES=0x00 SYN URGP=0 </span><span lang=EN-GB
style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'><o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Nachdem
Sie überprüft haben, <span class=GramE>das</span> eingehende Verbindungen
funktionieren, ist der nächste Schritt das Testen von ausgehenden Verbindungen.
Fangen Sie mit dem Zugriff auf einen der Honigtöpfe hinter dem <span
class=SpellE>Gateway</span> an (wir empfehlen, <span class=GramE>das</span> sie
über die Konsole auf die Honigtöpfe zugreifen, da der Honigtopf alle
Fernzugriffe, wie SSH, lokal protokolliert). Von dort aus versuchen Sie
Zugriffe auf verschiedene Systeme außerhalb des Honeynets. Dies entspricht der
Situation, <span class=GramE>das</span> ein Honigtopf kompromittiert worden ist
und jetzt von dort aus ausgehende Verbindungen versucht werden, möglicherweise
auch ein Angriff. Die Verbindungen sollten in /<span class=SpellE>var</span>/log/<span
class=SpellE>messages</span> auf der Honeywall protokolliert werden. In unserem
Fall können wir mehrere ausgehende FTP-Verbindungen zu dem Testsystem im Produktionsnetz
versuchen. Wenn wir das Limit von fünfzehn Verbindungen erreichen, wird ein
„Drop TCP“ Eintrag festgehalten. Sie sollten jetzt Einträge ähnlich diesen hier
sehen:<o:p></o:p></span></p>

<p><span class=SpellE><span style='font-size:10.0pt;font-family:"Courier New"'>Mar</span></span><span
style='font-size:10.0pt;font-family:"Courier New"'> 23 17:45:36 <span
class=SpellE>laptop</span> <span class=SpellE>kernel</span>: OUTBOUND CONN TCP:
IN=br0 PHYSIN=eth1 OUT=br0 PHYSOUT=eth0 SRC=192.168.1.101 DST=192.168.1.20
LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=36399 DF PROTO=TCP SPT=1026 DPT=80
WINDOW=5840 RES=0x00 SYN URGP=0 <br>
<span class=SpellE>Mar</span> 23 21:14:07 <span class=SpellE>laptop</span> <span
class=SpellE>kernel</span>: Drop TCP <span class=SpellE>after</span> 15 <span
class=SpellE>attempts</span> IN=br0 PHYSIN=eth1 OUT=br0 PHYSOUT=eth0 SRC=192.168.1.101
DST=192.168.1.20 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=63391 DF PROTO=TCP
SPT=1030 DPT=21 WINDOW=5840 RES=0x00 SYN URGP=0 </span><span style='font-size:
10.0pt;font-family:Arial'><o:p></o:p></span></p>

<p style='line-height:150%'><span style='font-family:Arial'>Als nächstes
möchten wir sicherstellen, das unsere <span class=SpellE>NIPS-Technologie</span>
(snort_inline) funktioniert. Glücklicherweise kommen die „drop <span
class=SpellE>rules</span>“ mit einigen Testregeln, die speziell für Tests
entworfen wurden. Stellen sie sicher, <span class=GramE>das</span> diese Regeln
aktiviert sind, bevor Sie die Tests starten. Das Regelwerk das Sie verwenden
legt auch fest, welche Tests Sie durchführen können. Nutzen Sie das „drop <span
class=SpellE>rules</span>“ Regelwerk, testen Sie einfach indem Sie zuerst die
Standardtestregel aktivieren, snort_inline mit dem <a
href="http://www.honeynet.org/papers/honeynet/tools/snort_inline.sh"><span
class=SpellE>snort_inline.sh</span></a> Startskript neu starten und dann
versuchen, eine ausgehende <span class=SpellE>telnet-Verbindung</span>
aufzubauen. Snort_inline sollte den Versuch erkennen, die Verbindung beenden
und ins Protokoll schreiben. Der <span class=SpellE>telnet-Versuch</span>
sollte nicht funktionieren sondern mit einem <span class=SpellE>Time-Out</span>
enden. Sollten Sie ein „<span class=SpellE>replace</span> <span class=SpellE>rules</span>“
Regelwerk verwenden, gehen Sie wie oben vor, nur versuchen sie statt <span
class=SpellE>telnet</span> ein HTTP GET Kommando. Auch hier sollte snort_inline
den Versuch bemerken, verändern und ins Protokoll schreiben. Um sicher zu gehen
<span class=GramE>das</span> die Veränderung stattgefunden hat, stellen Sie
sicher, dass Sie an der EXTERNEN Netzwerkkarte eth0 lauschen. Lauschen Sie
NICHT an der internen Karte eth1, da das GET Kommando erst geändert wird,
nachdem es die interne Karte passiert hat, aber bevor es die externe Karte <span
class=SpellE>verläßt</span>. Vergewissern Sie sich, dass Sie nach den Tests die
Testregeln wieder deaktivieren (oder die Bösen können diese Tests auch einfach
durchführen).<o:p></o:p></span></p>

<p><span lang=EN-GB style='font-size:10.0pt;font-family:"Courier New";
mso-ansi-language:EN-GB'>03/23-21:21:05.915340 [**] [1:0:0] Dropping Telnet
connection [**] [Priority: 0] {TCP} 192.168.1.101:39528 -&gt; 192.168.1.20:23<br>
03/23-21:21:24.054533 [**] [1:0:0] Modifying HTTP GET command [**] [Priority:
0] {TCP} 192.168.1.101:38533 -&gt; 192.168.1.20:80 </span><span lang=EN-GB
style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'><o:p></o:p></span></p>

<p style='line-height:150%'><span style='font-family:Arial'>Nachdem die Datenkontrolle
überprüft ist, testen wir die Datensammlung. Wenn unser Honeynet nicht alle
Aktivitäten protokolliert, dann hat es keinen Wert. Die Funktion der
Datensammlung prüfen wir durch Durchsicht der Protokolle. Hat das Honeynet die
gerade durchgeführten Tests protokolliert? Zuerst testen wir die <span
class=SpellE>Firewall-Protokolle</span>. Das ist einfach, da alle Verbindungen
nach /<span class=SpellE>var</span>/log/<span class=SpellE>messages</span> geschrieben
werden sollten. Im einzelnen sollten wir zuerst die eingehende Verbindung sehen,
danach die ausgehenden Verbindungen zu unserem Testsystem und als letztes eine
Warnmeldung das das Limit für ausgehende Verbindungen erreicht wurde und alle
weiteren Verbindungen verweigert werden. <o:p></o:p></span></p>

<p style='line-height:150%'><span style='font-family:Arial'>Als nächstes prüfen
wir die Netzwerkprotokolle. Wir möchten sichergehen, das wir jedes Paket und
den gesamten (Daten-)Inhalt jeder Verbindung, ein- und ausgehend, abgefangen
haben. Gemäß unseres Startskriptes sollten diese Protokolle unter /<span
class=SpellE>var</span>/log/<span class=SpellE>snort</span>/$DAY stehen, wobei
$DAY für den jeweiligen Tag steht. Unserer Erfahrung nach ist es am besten, die
Protokolle täglich neu zu beginnen. In diesem Fall stehen die gesuchten unter /<span
class=SpellE>var</span>/log/<span class=SpellE>snort</span>/Mar_23. Die Datei,
die uns hauptsächlich interessiert ist die binäre Protokolldatei <span
class=SpellE>snort.log</span>.*. Es ist möglich, dass Sie außerdem diverse
Verzeichnisse mit <span class=SpellE>IP-Adressen</span> als Namen finden. Diese
Verzeichnisse enthalten den Inhalt von Paket mit ASCII-Inhalten, wie z.B. FTP
Befehle oder <span class=SpellE>html-Seiten</span>. Sie können prüfen, ob <span
class=SpellE>snort</span> alle Pakete aufgezeichnet hat, indem Sie die binäre
Datei <span class=SpellE>snort.log</span>.* auswerten:<o:p></o:p></span></p>

<p style='line-height:150%'><span class=SpellE><span style='font-size:10.0pt;
line-height:150%;font-family:"Courier New"'>honeywall</span></span><span
style='font-size:10.0pt;line-height:150%;font-family:"Courier New"'> #<span
class=SpellE>snort</span> <span class=SpellE>-vdr</span> <span class=SpellE>snort.log</span>.*<o:p></o:p></span></p>

<p style='line-height:150%'><span style='font-family:Arial'>Zum <span
class=SpellE>Schluß</span> überprüfen wir die Sebek2 Protokolle. Hier finden
sich die Tastatureingaben die das Sebek2 <span class=SpellE>Kernelmodul</span>
protokolliert und über das Netzwerk gesendet hat. Diese Pakete sollte der <span
class=SpellE>Sniffer</span> (<span class=SpellE>snort</span>) abgefangen haben
und man sollte daher in der Lage sein, sie aus derselben Binärdatei die wir
gerade analysiert haben, wiederherzustellen. Dazu nutzen wir zuerst <span
class=SpellE>sebeksniff</span>, um die Daten wiederherzustellen. <span
class=SpellE>Sebeksniff</span> erstellt für jeden Honigtopf (basierend auf der <span
class=SpellE>IP-Adresse</span>) eine eigene Datei in /<span class=SpellE>var</span>/log/<span
class=SpellE>sebek</span>, die wir dann z.B. nach <span class=SpellE>Tastaureingaben</span>
oder Dateiübertragungen per <span class=SpellE>scp</span> (<span class=SpellE>secure</span>
<span class=SpellE>copy</span>) durchsuchen können. Die hierzu nötigen
Kommandos sind <o:p></o:p></span></p>

<p style='line-height:150%'><span class=SpellE><span style='font-size:10.0pt;
line-height:150%;font-family:"Courier New"'>honeywall</span></span><span
style='font-size:10.0pt;line-height:150%;font-family:"Courier New"'> #<span
class=SpellE>sebeksniff</span> -p 34557 -f <span class=SpellE>snort.log</span>.*<br>
<span class=SpellE>honeywall</span> #<a
href="http://www.honeynet.org/papers/gen2/sbdump.txt">sbdump.pl -c /<span
class=SpellE>var</span>/log/<span class=SpellE>sebek</span>/192.168.1.101</a><o:p></o:p></span></p>

<p style='line-height:150%'><span style='font-family:Arial'>Und das war es.
Wenn Sie die Daten analysieren konnten, hat Ihre Datensammlung korrekt
gearbeitet. Schauen Sie auch nach Ihrer E-Mail: Sie sollten von Swatch über die
gerade gelaufenen Tests benachrichtigt worden sein. Und da Sie ein echter Profi
im Bereich der <span class=SpellE>Security</span> sind, wissen wir, das Sie ihr
Honeynet <span class=SpellE>Gateway</span> einmal neu starten und noch einmal
testen werden, nur um sicher zu gehen ;)<o:p></o:p></span></p>

<p><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<h3><u>Nachwort<o:p></o:p></u></h3>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'>Wir
haben soeben Schritt für Schritt gelernt, wie man ein GenII Honeynet basierend
auf einem <span class=SpellE>Bridging</span> <span class=SpellE>Gateway</span>
unter Linux aufsetzt. Diese Installation nutzt einige der fortgeschrittensten
Technologien für Honeynets. Für die Zukunft hoffen wir, <span class=SpellE>GUIs</span>
für die Administration von Honeynets und die Analyse der gesammelten Daten entwickeln
und veröffentlichen zu können. Außerdem arbeiten wir an einer bootfähigen
Honeywall CD die alle Fähigkeiten mitbringt, die hier besprochen wurden.<o:p></o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='line-height:150%'><span style='font-family:Arial'><o:p>&nbsp;</o:p></span></p>

<p style='line-height:150%'><span class=berschrift3Char><u><span
style='font-size:13.0pt;line-height:150%'>Anm. d. Übers</span></u></span><span
class=text1><b><span style='font-size:8.0pt;line-height:150%'>.</span></b></span><span
style='font-size:8.0pt;line-height:150%;font-family:Verdana;color:black'><br>
<br>
</span><span class=text1><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;line-height:150%;font-family:Arial;mso-bidi-font-family:"Times New Roman"'>Ich
bin kein professioneller Übersetzer, deswegen ist es sehr wahrscheinlich, <span
class=GramE>das</span> man vieles besser hätte formulieren können. Trotzdem
hoffe ich, dass sich nirgendwo grobe Sinnentstellungen oder gar Fehler
eingeschlichen haben. Wenn doch, oder auch bei sonstiger Kritik oder gar Lob,
kurze E-Mail reicht und dann wird korrigiert.</span></span><span
style='font-family:Arial;mso-bidi-font-family:"Times New Roman";color:black'><br>
<br>
<span class=text1><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;line-height:150%;font-family:Arial;mso-bidi-font-family:"Times New Roman"'>Der
Artikel wurde von mir mit größter Sorgfalt übersetzt. Trotzdem sind inhaltliche
Fehler nicht ganz auszuschließen. Ich weise deshalb darauf hin, dass ich weder
eine Garantie bzw. Gewährleistung noch die Verantwortung oder Haftung für
Folgen jeglicher Art, die aus der Nutzung der hier geschilderten Angaben
entstehen könnten, übernehme. Alle durchgeführten Veränderungen werden auf
eigene Gefahr, sowie freiwillig und unabhängig von dem Inhalt dieser Web-Seite
vorgenommen. Der Originalartikel ist hier zu finden:</span></span></span><span
style='font-size:8.0pt;line-height:150%;font-family:Verdana;color:black'><br>
</span><span class=text1><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;line-height:150%;font-family:Arial'>http://www.honeynet.org/papers/gen2</span></span><span
class=text1><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
line-height:150%'><o:p></o:p></span></span></p>

</div>

</body>

</html>

