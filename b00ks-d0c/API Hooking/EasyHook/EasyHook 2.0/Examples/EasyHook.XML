<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EasyHook</name>
    </assembly>
    <members>
        <member name="T:EasyHook.Debugger">
            <summary>
            Provides some important methods to work with hook handler parameters.
            </summary>
            <remarks><para>
            The most important methods are <see cref="M:EasyHook.Debugger.GetThreadIdByHandle(System.IntPtr)"/>,
            <see cref="M:EasyHook.Debugger.GetProcessIdByHandle(System.IntPtr)"/> and <see cref="M:EasyHook.Debugger.QueryObjectInformation(System.IntPtr)"/>.
            These will allow you to get common information out of handles that
            are passed to your hook handler by external code. Imagine a situation in which
            you would like to hook <c>Kernel32::ReadFile</c> for example. You won't get
            any information about the file that is described by a handle when using the
            regular windows API. <see cref="M:EasyHook.Debugger.QueryObjectInformation(System.IntPtr)"/> now provides a way
            to get the kernel object name for this file handle which is indeed the file
            name. The same thing applies to threads and processes. You are now able to
            get the underlying TID and PID from a usual windows thread-/process-handle.
            Such information is indispensable for any hook handler.
            </para></remarks>
        </member>
        <member name="M:EasyHook.Debugger.GetThreadIdByHandle(System.IntPtr)">
            <summary>
            Tries to get the underlying thread ID for a given handle.
            </summary>
            <remarks>
            This is not always possible. The handle has to be opened with <c>THREAD_QUERY_INFORMATION</c>
            access. If any error occurs, the method tries to get a more convenient error description
            using the debugging engine, if supported.
            </remarks>
            <param name="InThreadHandle">A valid thread handle.</param>
            <returns>A valid thread ID associated with the given thread handle.</returns>
            <exception cref="T:System.InvalidCastException">The given handle does exist, but is not a thread handle.</exception>
            <exception cref="T:System.AccessViolationException">
            The given handle does exist, is a thread handle, but was not opened with <c>THREAD_QUERY_INFORMATION</c> access.</exception>
            <exception cref="T:System.ArgumentException">
            The handle is invalid or no extended error information was available. 
            </exception>
            <exception cref="T:System.NotSupportedException">
            Should never occur and just notifies you that a handle to thread ID conversion is not
            available on the current platform.
            </exception>
        </member>
        <member name="M:EasyHook.Debugger.GetProcessIdByHandle(System.IntPtr)">
            <summary>
            Tries to get the underlying process ID for a given handle.
            </summary>
            <remarks>
            This is not always possible. The handle has to be opened with <c>PROCESS_QUERY_INFORMATION</c>
            access. If any error occurs, the method tries to get a more convenient error description
            using the debugging engine, if supported.
            </remarks>
            <param name="InProcessHandle">A valid process handle.</param>
            <returns>A valid process ID associated with the given process handle.</returns>
            <exception cref="T:System.InvalidCastException">The given handle does exist, but is not a process handle.</exception>
            <exception cref="T:System.AccessViolationException">
            The given handle does exist, is a process handle, but was not opened with <c>PROCESS_QUERY_INFORMATION</c> access.</exception>
            <exception cref="T:System.ArgumentException">
            The handle is invalid or no extended error information was available. 
            </exception>
            <exception cref="T:System.NotSupportedException">
            Should never occur and just notifies you that a handle to thread ID conversion is not
            available on the current platform.
            </exception>
        </member>
        <member name="M:EasyHook.Debugger.QueryObjectInformation(System.IntPtr)">
            <summary>
            Reads the kernel object entry for a given windows usermode handle.
            </summary>
            <remarks><para>
            This allows you to translate a handle back to the associated filename for example.
            But keep in mind that such names are only valid for kernel service routines, like
            <c>NtCreateFile</c>. You won't have success when calling <c>CreateFile</c> on such
            object names! The regular windows user mode API has some methods that will allow
            you to convert such kernelmode names back into usermode names. I know this because I did it
            some years ago but I've already forgotten how it has to be done! I can only give you
            some hints: <c>FindFirstVolume()</c>, <c>FindFirstVolumeMountPoint()</c>,
            <c>QueryDosDevice()</c>, <c>GetVolumePathNamesForVolumeName()</c>
            </para><para>
            I assume that this method isn't that fast, so don't use it in fequently called API's
            like <c>ReadFile</c> or something similar. I recommend using it only to
            add unknown handles to your hooking service. All newly created handles should be
            intercepted through methods like <c>CreateFileW</c>, so that you can use a handle
            index table which is much faster. This way you only need to query the kernel object if you got
            a handle that you don't know about, e.g. that is not already in your handle index table!
            </para></remarks>
            <param name="InHandle">A valid usermode handle.</param>
            <returns>An object information instance for the given handle.</returns>
            <exception cref="T:System.NotSupportedException">
            This operation is not supported on the current platform, what is common on Windows 2000.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            You have disabled debugging!
            </exception>
            <exception cref="T:System.ArgumentException">
            The given handle is invalid or could not be accessed for unknown reasons.
            </exception>
        </member>
        <member name="M:EasyHook.Debugger.Disassemble(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Even if you don't want to write a disassembler it is sometimes helpful to include
            disassembly of entry points in error reports for example. EasyHook does this
            automatically but you may also provide your custom reports.
            </summary>
            <remarks>
            Keep in mind that this method will operate on the current processor architecture only.
            You can't disassemble 32-bit code when running under 64-bit and vice versa.
            </remarks>
            <param name="InCodePtr">A pointer to the binary machine code being disassembled.</param>
            <param name="InMaxByteCount">The maximum amount of bytes to disassemble.</param>
            <param name="InLineIndent">The amount of spaces inserted in front of each line.</param>
            <returns>The disassembly of the given machine code portion.</returns>
            <exception cref="T:System.NotSupportedException">
            This operation is not supported on the current platform, what is common on Windows 2000.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            You have disabled debugging!
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            A positive byte count is expected.
            </exception>
            <exception cref="T:System.ArgumentException">
            The given memory range does not map to valid memory or contain invalid instructions.
            </exception>
        </member>
        <member name="P:EasyHook.Debugger.IsEnabled">
            <summary>
            Set to <c>true</c> if you want to allow debugging, <c>false</c> otherwise.
            </summary>
            <remarks>
            This property is defaulted to be <c>true</c>. Please note that if you disable
            debugging, <see cref="M:EasyHook.Debugger.QueryObjectInformation(System.IntPtr)"/> and <see cref="M:EasyHook.Debugger.Disassemble(System.IntPtr,System.Int32,System.Int32)"/>
            won't work anymore. <see cref="P:EasyHook.Debugger.IsAvailable"/> is not affected by this property. 
            Local hooking will lose stability without debugging support,
            in particular on 64-bit (RIP relative addressing is not detected or
            relocated).
            </remarks>
        </member>
        <member name="P:EasyHook.Debugger.IsAvailable">
            <summary>
            Returns <c>true</c>, if debugging is supported on the current machine,
            <c>false</c> otherwise.
            </summary>
            <remarks>
            On Windows 2000 you are required to provide the "dbgeng.dll" and "dbghelp.dll" which
            ship with "Debugging Tools for Windows 32-Bit Version" on your own... Otherwise 
            debugging is not supported. Just donwload the package from Microsoft and redistribute
            the two files in the base directory of the application that will later be used for injection.
            Because Easy will automaticall adjust the PATH variable of targets, these two files will
            remain accessible there, even if they are not in the system directory. "dbghelp.dll" is
            already ships with Windows 2000 but is not compatible to any current "dbgeng.dll" and overwriting
            system files is not recommended!
            </remarks>
        </member>
        <member name="P:EasyHook.Debugger.CanUse">
            <summary>
            Returns <c>true</c>, if <see cref="P:EasyHook.Debugger.IsAvailable"/> and <see cref="P:EasyHook.Debugger.IsEnabled"/> are <c>true</c>,
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="T:EasyHook.Debugger.ObjectInfo">
            <summary>
            Holds all information available for a given handle. In particular this
            class describes the related handle's kernel object entry and not the handle itself.
            </summary>
        </member>
        <member name="P:EasyHook.Debugger.ObjectInfo.Attributes">
            <summary>
            A bit-set that contains the handle's attributes. For possible values, see the Windows Driver Kit (WDK).
            </summary>
        </member>
        <member name="P:EasyHook.Debugger.ObjectInfo.GrantedAccess">
            <summary>
            A bit-set that specifies the access mask for the object that is represented by the handle. 
            For details, see <c>ACCESS_MASK</c> in the Platform SDK documentation. 
            </summary>
        </member>
        <member name="P:EasyHook.Debugger.ObjectInfo.HandleCount">
            <summary>
            The number of handle references for the object. (usermode)
            </summary>
        </member>
        <member name="P:EasyHook.Debugger.ObjectInfo.PointerCount">
            <summary>
            The number of pointer references for the object. (kernelmode)
            </summary>
        </member>
        <member name="P:EasyHook.Debugger.ObjectInfo.TypeName">
            <summary>
            The string representation for <see cref="P:EasyHook.Debugger.ObjectInfo.Type"/>.
            </summary>
        </member>
        <member name="P:EasyHook.Debugger.ObjectInfo.ObjectName">
            <summary>
            An empty string if this entry does not refer to a named kernel object.
            Otherwise a full qualified path to a named kernel object. This will
            be a filename for example if <see cref="P:EasyHook.Debugger.ObjectInfo.Type"/> is <c>ObjectType.File</c>.
            </summary>
        </member>
        <member name="P:EasyHook.Debugger.ObjectInfo.Type">
            <summary>
            Holds the kernel object type of this entry.
            </summary>
        </member>
        <member name="T:EasyHook.ObjectType">
            <summary>
            Covers all well known object entry types. Refer to <see cref="T:EasyHook.Debugger.ObjectInfo"/>
            for more information. Please note that this documentation does not list them. Refer
            to the IntelliSense values or the Windows Driver Kit for a complete enumeration.
            </summary>
        </member>
        <member name="F:EasyHook.ObjectType.Unknown">
            <summary>
            The handle refers to an unknown object entry type. 
            </summary>
        </member>
        <member name="T:EasyHook.HookRuntimeInfo">
            <summary>
            This class is intended to be used within hook handlers,
            to access associated runtime information.
            </summary>
            <remarks>
            Other hooking libraries on the market require that you keep track of
            such information yourself, what can be a burden.
            </remarks>
        </member>
        <member name="P:EasyHook.HookRuntimeInfo.IsHandlerContext">
            <summary>
            Is the current thread within a valid hook handler? This is only the case
            if your handler was called through the hooked entry point...
            </summary>
        </member>
        <member name="P:EasyHook.HookRuntimeInfo.Callback">
            <summary>
            The user callback initially passed to either <see cref="M:EasyHook.LocalHook.Create(System.IntPtr,System.Delegate,System.Object)"/> or <see cref="M:EasyHook.LocalHook.CreateUnmanaged(System.IntPtr,System.IntPtr)"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> The current thread is not within a valid hook handler. </exception>
        </member>
        <member name="P:EasyHook.HookRuntimeInfo.Handle">
            <summary>
            The hook handle initially returned by either <see cref="M:EasyHook.LocalHook.Create(System.IntPtr,System.Delegate,System.Object)"/> or <see cref="M:EasyHook.LocalHook.CreateUnmanaged(System.IntPtr,System.IntPtr)"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> The current thread is not within a valid hook handler. </exception>
        </member>
        <member name="P:EasyHook.HookRuntimeInfo.ReturnAddress">
            <summary>
            The address from which your handler was called, i.e. where it will return to.
            In conjunction with <see cref="P:EasyHook.HookRuntimeInfo.InitialRSP"/> this will allow a stack trace...
            </summary>
            <exception cref="T:System.InvalidOperationException"> The current thread is not within a valid hook handler. </exception>
        </member>
        <member name="P:EasyHook.HookRuntimeInfo.InitialRSP">
            <summary>
            The initial RSP value at entry point. In conjunction with <see cref="P:EasyHook.HookRuntimeInfo.ReturnAddress"/> this will
            allow a stack trace...
            </summary>
            <exception cref="T:System.InvalidOperationException"> The current thread is not within a valid hook handler. </exception>
        </member>
        <member name="T:EasyHook.HookAccessControl">
            <summary>
            Provides a managed interface to the native thread ACLs.
            </summary>
            <remarks>
            Refer to the official guide to learn more about why thread ACLs are useful. 
            They can be used to exclude/include dedicated threads from interception or to dynamically
            apply different kind of hooks to different threads. Even if you could do this
            in managed code, it is not that easy to implement and also EasyHook evaluates
            those ACLs in unmanaged code. So if any thread is not intercepted, it will never
            enter the manged environment what will speed up things about magnitudes.
            </remarks>
        </member>
        <member name="M:EasyHook.HookAccessControl.SetInclusiveACL(System.Int32[])">
            <summary>
            Sets an inclusive ACL. This means all threads that are enumerated through <paramref name="InACL"/>
            are intercepted while all others are NOT. Of course this will overwrite the existing ACL.
            </summary>
            <remarks>
            Please note that this is not necessarily the final
            negotiation result. Refer to <see cref="M:EasyHook.LocalHook.IsThreadIntercepted(System.Int32)"/> for more information.
            In general inclusive ACLs will restrict exclusive ACLs while local ACLs will overwrite the
            global ACL.
            </remarks>
            <param name="InEntries">Threads to be explicitly included in negotiation.</param>
            <exception cref="T:System.InvalidOperationException">
            The limit of 128 access entries is exceeded!
            </exception>
        </member>
        <member name="M:EasyHook.HookAccessControl.SetExclusiveACL(System.Int32[])">
            <summary>
            Sets an exclusive ACL. This means all threads that are enumerated through <paramref name="InACL"/>
            are NOT intercepted while all others are. Of course this will overwrite the existing ACL.
            </summary>
            <remarks>
            Please note that this is not necessarily the final
            negotiation result. Refer to <see cref="M:EasyHook.LocalHook.IsThreadIntercepted(System.Int32)"/> for more information.
            In general inclusive ACLs will restrict exclusive ACLs while local ACLs will overwrite the
            global ACL.
            </remarks>
            <param name="InEntries">Threads to be explicitly included in negotiation.</param>
            <exception cref="T:System.InvalidOperationException">
            The limit of 128 access entries is exceeded!
            </exception>
        </member>
        <member name="M:EasyHook.HookAccessControl.GetEntries">
            <summary>
            Creates a copy of the internal thread list associated with this ACL. You may freely
            modify it without affecting the internal entries.
            </summary>
            <returns>
            A copy of the internal thread entries.
            </returns>
        </member>
        <member name="P:EasyHook.HookAccessControl.IsExclusive">
            <summary>
            Is this ACL an exclusive one? Refer to <see cref="M:EasyHook.HookAccessControl.SetExclusiveACL(System.Int32[])"/> for more information.
            </summary>
        </member>
        <member name="P:EasyHook.HookAccessControl.IsInclusive">
            <summary>
            Is this ACL an inclusive one? Refer to <see cref="M:EasyHook.HookAccessControl.SetInclusiveACL(System.Int32[])"/> for more information.
            </summary>
        </member>
        <member name="T:EasyHook.LocalHook">
            <summary>
            This class will provide various static members to be used with local hooking and
            is also the instance class of a hook.
            </summary>
            <remarks>
  The following demonstrates how to use <see cref="T:EasyHook.LocalHook"/>:
  <code>
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Runtime.InteropServices;
using EasyHook;

namespace FileMonInject
{
    public class Main : EasyHook.IEntryPoint
    {
        FileMon.FileMonInterface Interface;
        LocalHook CreateFileHook;
        Stack&lt;String&gt; Queue = new Stack&lt;String&gt; ();

        public Main(
            RemoteHooking.IContext InContext,
            String InChannelName)
        {
            // connect to host...
            Interface = RemoteHooking.IpcConnectClient&lt;FileMon.FileMonInterface&gt;(InChannelName);
            
            // validate connection...
            Interface.Ping();
        }

        public void Run(
            RemoteHooking.IContext InContext,
            String InChannelName)
        {
            // install hook...
            try
            {
                
                LocalHook.BeginUpdate(true);

                CreateFileHook = LocalHook.Create(
                    LocalHook.GetProcAddress("kernel32.dll", "CreateFileW"),
                    new DCreateFile(CreateFile_Hooked),
                    this);
                
                LocalHook.EndUpdate();

                CreateFileHook.ThreadACL.SetExclusiveACL(new Int32[] { 0 });
            }
            catch (Exception ExtInfo)
            {
                Interface.ReportException(ExtInfo);

                return;
            }

            Interface.IsInstalled(RemoteHooking.GetCurrentProcessId());

            RemoteHooking.WakeUpProcess();

            // wait for host process termination...
            try
            {
                while (true)
                {
                    Thread.Sleep(500);

                    // transmit newly monitored file accesses...
                    if (Queue.Count &gt; 0)
                    {
                        String[] Package = null;

                        lock (Queue)
                        {
                            Package = Queue.ToArray();

                            Queue.Clear();
                        }

                        Interface.OnCreateFile(RemoteHooking.GetCurrentProcessId(), Package);
                    }
                    else
                        Interface.Ping();
                }
            }
            catch
            {
                // Ping() will raise an exception if host is unreachable
            }
        }

        [UnmanagedFunctionPointer(CallingConvention.StdCall,
            CharSet = CharSet.Unicode,
            SetLastError = true)]
        delegate IntPtr DCreateFile(
            String InFileName,
            UInt32 InDesiredAccess,
            UInt32 InShareMode,
            IntPtr InSecurityAttributes,
            UInt32 InCreationDisposition,
            UInt32 InFlagsAndAttributes,
            IntPtr InTemplateFile);

        // just use a P-Invoke implementation to get native API access from C# (this step is not necessary for C++.NET)
        [DllImport("kernel32.dll",
            CharSet = CharSet.Unicode,
            SetLastError = true,
            CallingConvention = CallingConvention.StdCall)]
        static extern IntPtr CreateFile(
            String InFileName,
            UInt32 InDesiredAccess,
            UInt32 InShareMode,
            IntPtr InSecurityAttributes,
            UInt32 InCreationDisposition,
            UInt32 InFlagsAndAttributes,
            IntPtr InTemplateFile);

        // this is where we are intercepting all file accesses!
        static IntPtr CreateFile_Hooked(
            String InFileName,
            UInt32 InDesiredAccess,
            UInt32 InShareMode,
            IntPtr InSecurityAttributes,
            UInt32 InCreationDisposition,
            UInt32 InFlagsAndAttributes,
            IntPtr InTemplateFile)
        {
            
            try
            {
                Main This = (Main)HookRuntimeInfo.Callback;

                lock (This.Queue)
                {
                    This.Queue.Push("[" + RemoteHooking.GetCurrentProcessId() + ":" + 
                        RemoteHooking.GetCurrentThreadId() +  "]: \"" + InFileName + "\"");
                }
            }
            catch
            {
            }

            // call original API...
            return CreateFile(
                InFileName,
                InDesiredAccess,
                InShareMode,
                InSecurityAttributes,
                InCreationDisposition,
                InFlagsAndAttributes,
                InTemplateFile);
        }
    }
}

  </code>
</remarks>
        </member>
        <member name="M:EasyHook.LocalHook.Dispose">
            <summary>
            If you want to immediately uninstall a hook, the only way is to dispose it. A disposed
            hook is guaranteed to never invoke your handler again but may still consume
            memory even for process life-time! 
            </summary>
            <remarks>
            As we are living in a manged world, you don't have to dispose a hook because the next 
            garbage collection will do it for you, assuming that your code does not reference it
            anymore. But there are times when you want to uninstall it excplicitly, with no delay.
            If you dispose a disposed or not installed hook, nothing will happen!
            </remarks>
        </member>
        <member name="M:EasyHook.LocalHook.BeginUpdate(System.Boolean)">
            <summary>
            Begins a new installation sequence of hooks. You have to close it with either <see cref="M:EasyHook.LocalHook.EndUpdate"/> or
            <see cref="M:EasyHook.LocalHook.CancelUpdate"/>.
            </summary>
            <remarks>
            <para>
            Please note that all hooks are installed in the <see cref="M:EasyHook.LocalHook.EndUpdate"/> call. If you successfully
            created all hooks, this does not necessarily mean that the hooks are installable. If a hook
            fails to install in the <see cref="M:EasyHook.LocalHook.EndUpdate"/> call, all hooks contained in the related
            installation sequence are removed. The same applies if you call <see cref="M:EasyHook.LocalHook.CancelUpdate"/> instead.
            </para>
            </remarks>
            <param name="InIgnoreWarnings"><c>true</c> if you want to hook all entry points, even if it is
            considered to be unsafe, <c>false</c> otherwise.</param>
        </member>
        <member name="M:EasyHook.LocalHook.EndUpdate">
            <summary>
            This will finally try to install all hooks of the current installation sequence. 
            An exception is thrown, if a hook could not be installed. 
            </summary>
            <exception cref="T:System.InvalidOperationException">
            You have to call <see cref="M:EasyHook.LocalHook.BeginUpdate(System.Boolean)"/> first or you already have called <see cref="M:EasyHook.LocalHook.CancelUpdate"/> or
            <see cref="M:EasyHook.LocalHook.EndUpdate"/> for the current installation sequence.
            </exception>
            <exception cref="T:System.InvalidProgramException">
            At least one thread seems to hang in one entry point of the current installation sequence.
            You may catch this exception and simply retry by executing all instructions including thre related
            <see cref="M:EasyHook.LocalHook.BeginUpdate(System.Boolean)"/> again... This is a very rare exception and in general there is no need to do so!
            </exception>
            <exception cref="T:System.ExecutionEngineException">
            The engine does not recommend hooking for at least one entry point and you don't want to ignore such warnings.
            </exception>
            <exception cref="T:System.ArgumentException">
            At least one entry point contains invalid machine code instructions.
            </exception>
            <exception cref="T:System.NotSupportedException">
            At least one entry point is not hookable because of currently unrelocatable/unsupported machine code.
            </exception>
            <exception cref="T:System.OutOfMemoryException">
            Unable to allocate memory for at leat one hook. On 64-Bit this may also occur if no memory within
            a 31-Bit range could be allocated around the entry point.
            </exception>
        </member>
        <member name="M:EasyHook.LocalHook.CancelUpdate">
            <summary>
            Will cancel the current installation sequence and won't install any hook. Don't call
            <see cref="M:EasyHook.LocalHook.EndUpdate"/> in this case...
            </summary>
            <exception cref="T:System.InvalidOperationException">
            You have to call <see cref="M:EasyHook.LocalHook.BeginUpdate(System.Boolean)"/> first or you already have called <see cref="M:EasyHook.LocalHook.CancelUpdate"/> or
            <see cref="M:EasyHook.LocalHook.EndUpdate"/> for the current installation sequence.
            </exception>
        </member>
        <member name="M:EasyHook.LocalHook.Create(System.IntPtr,System.Delegate,System.Object)">
            <summary>
            Will install a managed hook. Please note that a hook
            starts with <see cref="P:EasyHook.LocalHook.IsInstalled"/> set to <c>false</c> until you call the final
            <see cref="M:EasyHook.LocalHook.EndUpdate"/>. After this you'll have to activate it by setting a proper <see cref="P:EasyHook.LocalHook.ThreadACL"/>.
            </summary>
            <remarks>
            <para>
            Note that not all entry points are hookable! In general methods like <c>CreateFileW</c>
            won't cause any trouble. But there might be methods that are not hookable because their
            entry point machine code is not eligable to be hooked. You should test all hooks on
            common environments like "Windows XP x86/x64 SP2/SP3" and "Windows Vista x86/x64 (SP1)".
            This is the only way to ensure that your application will work well on most machines.
            </para><para>
            Your handler delegate has to use the <see cref="T:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute"/> and
            shall map to the same native method signature, otherwise the application will crash! The best
            way is to use predefined delegates used in related P-Invoke implementations usually found with Google.
            If you know how to write such native delegates you won't need internet resources of course.
            I recommend using C++.NET which allows you to just copy the related windows API to your managed
            class and thread it as delegate without any changes. This will also speed up the whole thing
            because no unnecessary marshalling is required! C++.NET is also better in most cases because you
            may access the whole native windows API from managed code without any effort what significantly eases
            writing of hook handlers.
            </para>
            <para>
            The given delegate is automatically prevented from being garbage collected until the hook itself
            is collected...
            </para>
            </remarks>
            <param name="InTargetProc">A target entry point that should be hooked.</param>
            <param name="InNewProc">A handler with the same signature as the original entry point
            that will be invoked for every call that has passed the Fiber Deadlock Barrier and various integrity checks.</param>
            <param name="InCallback">An uninterpreted callback that will later be available through <see cref="P:EasyHook.HookRuntimeInfo.Callback"/>.</param>
            <returns>
            A handle to the newly created hook.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            You have to call <see cref="M:EasyHook.LocalHook.BeginUpdate(System.Boolean)"/> first or you already have called <see cref="M:EasyHook.LocalHook.CancelUpdate"/> or
            <see cref="M:EasyHook.LocalHook.EndUpdate"/> for the current installation sequence.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The given entry point is used internally and therefore can't be intercepted! This will currently apply to
            <c>TlsSetValue()</c>/<c>TlsGetValue()</c> or <c>FlsSetValue()</c>/<c>FlsGetValue()</c> if supported.
            </exception>
            <exception cref="T:System.ArgumentException">
            The given function pointer does not map to executable memory or you passed <c>null</c> as delegate.
            </exception>
        </member>
        <member name="M:EasyHook.LocalHook.CreateUnmanaged(System.IntPtr,System.IntPtr)">
            <summary>
            Installs an unmanaged hook. <see cref="T:EasyHook.HookRuntimeInfo"/> WON'T be supported!
            In contrast, the fiber deadlock barrier will still apply. Please note that a hook
            starts with <see cref="P:EasyHook.LocalHook.IsInstalled"/> set to <c>false</c> until you call the related
            <see cref="M:EasyHook.LocalHook.EndUpdate"/>. After this you'll have to activate it by setting a proper <see cref="P:EasyHook.LocalHook.ThreadACL"/>.
            </summary>
            <remarks>
            <para>
            Note that not all entry points are hookable! In general methods like <c>CreateFileW</c>
            won't cause any trouble. But there may be methods that are not hookable because their
            entry point machine code is not eligable to be hooked. You should test all hooks on
            common environments like "Windows XP x86/x64 SP1/SP2/SP3" and "Windows Vista x86/x64 (SP1)".
            This is the only way to ensure that your application will work well on most machines.
            </para><para>
            Unmanaged hooks will require a native DLL which handles the requests. In general
            this was not intended by EasyHook but as I don't want to restrict things to managed
            code, you will get a high-performance interface with this method. This is because
            a switch from unmanaged to managed code seems to be rather time consuming without doing anything
            useful (at least nothing visible); so a hook omitting this switch will be handled one or two
            magnitudes faster until finally your handler gains execution. But as a hook is still executed
            within at last 1000 nano-seconds, even the "slow" managed implementation will be fast enough in most
            cases. With C++.NET you would be able to provide such native high-speed hooks for frequently
            called API methods, while still using managed ones for usual API methods, within a single assembly!
            A pure unmanaged, empty hook executes in approx. 70 nano-seconds, which is incredible fast
            considering the thread deadlock barrier and thread ACL negotiation that are already included in this benchmark!
            </para>
            </remarks>
            <param name="InTargetProc">A target entry point that should be hooked.</param>
            <param name="InNewProc">A handler with the same signature as the original entry point
            that will be invoked for every call that has passed the Fiber Deadlock Barrier and various integrity checks.</param>
            <returns>
            A handle to the newly created hook.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            You have to call <see cref="M:EasyHook.LocalHook.BeginUpdate(System.Boolean)"/> first or you already have called <see cref="M:EasyHook.LocalHook.CancelUpdate"/> or
            <see cref="M:EasyHook.LocalHook.EndUpdate"/> for the current installation sequence.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The given entry point is used internally and therefore can't be intercepted! This will currently apply to
            <c>TlsSetValue()</c>/<c>TlsGetValue()</c> or <c>FlsSetValue()</c>/<c>FlsGetValue()</c> if supported.
            </exception>
            <exception cref="T:System.ArgumentException">
            One of the given function pointers does not map to executable memory.
            </exception>
        </member>
        <member name="M:EasyHook.LocalHook.GetProcAddress(System.String,System.String)">
            <summary>
            Will return the address for a given DLL export symbol. The specified
            module has to be loaded into the current process space and also export
            the given method.
            </summary>
            <remarks>
            If you wonder how to get native entry points in a managed environment,
            this is the anwser. You will only be able to hook native code from a managed
            environment if you have access to a method like this, returning the native
            entry point. Please note that you will also hook any managed code, which
            of course ultimately relies on the native windows API!
            </remarks>
            <param name="InModule">A system DLL name like "kernel32.dll" or a full qualified path to any DLL.</param>
            <param name="InSymbolName">An exported symbol name like "CreateFileW".</param>
            <returns>The entry point for the given API method.</returns>
            <exception cref="T:System.OutOfMemoryException">
            Not enough unmanaged memory available to complete the call.
            </exception>
            <exception cref="T:System.DllNotFoundException">
            The given module is not loaded into the current process.
            </exception>
            <exception cref="T:System.MissingMethodException">
            The given module does not export the given method.
            </exception>
        </member>
        <member name="M:EasyHook.LocalHook.GetProcDelegate``1(System.String,System.String)">
            <summary>
            Will return a delegate for a given DLL export symbol. The specified
            module has to be loaded into the current process space and also export
            the given method.
            </summary>
            <remarks><para>
            This method is usually not useful to hook something but it allows you
            to dynamically load native API methods into your managed environment instead
            of using the static P-Invoke approach provided by <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/>.
            </para></remarks>
            <typeparam name="TDelegate">A delegate using the <see cref="T:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute"/> and
            exposing the same method signature as the specified native symbol.</typeparam>
            <param name="InModule">A system DLL name like "kernel32.dll" or a full qualified path to any DLL.</param>
            <param name="InSymbolName">An exported symbol name like "CreateFileW".</param>
            <returns>The managed delegate wrapping around the given native symbol.</returns>
            <exception cref="T:System.OutOfMemoryException">
            Not enough unmanaged memory available to complete the call.
            </exception>
            <exception cref="T:System.DllNotFoundException">
            The given module is not loaded into the current process.
            </exception>
            <exception cref="T:System.MissingMethodException">
            The given module does not export the given method.
            </exception>
        </member>
        <member name="M:EasyHook.LocalHook.IsThreadIntercepted(System.Int32)">
            <summary>
            Checks whether a given thread ID will be intercepted by the underlying hook.
            </summary>
            <remarks>
            <para>
            This method provides an interface to the internal negotiation algorithm.
            You may use it to check whether your ACL provides expected results.
            </para><para>
            The following is a pseudo code of how this method is implemented:
            <code>
            if(InThreadID == 0)
                InThreadID = GetCurrentThreadId();
            
            if(GlobalACL.Contains(InThreadID))
            {
                if(LocalACL.Contains(InThreadID))
            	{
            		if(LocalACL.IsExclusive)
            			return false;
            	}
            	else
            	{
            		if(GlobalACL.IsExclusive)
            			return false;
            
            		if(!LocalACL.IsExclusive)
            			return false;
            	}
            }
            else
            {
            	if(LocalACL.Contains(InThreadID))
            	{
            		if(LocalACL.IsExclusive)
            			return false;
            	}
            	else
            	{
            		if(!GlobalACL.IsExclusive)
            			return false;
            
            		if(!LocalACL.IsExclusive)
            			return false;
            	}
            }
            
            return true;
            </code>
            </para>
            </remarks>
            <param name="InThreadID">A native OS thread ID; or zero if you want to check the current thread.</param>
            <returns><c>true</c> if the thread is intercepted, <c>false</c> otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">
            The underlying hook is not installed or already disposed.
            </exception>
        </member>
        <member name="P:EasyHook.LocalHook.ThreadACL">
            <summary>
            Returns the thread ACL associated with this hook. Refer to <see cref="M:EasyHook.LocalHook.IsThreadIntercepted(System.Int32)"/>
            for more information about access negotiation.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The underlying hook is not installed or already disposed.
            </exception>
        </member>
        <member name="P:EasyHook.LocalHook.IsInstalled">
            <summary>
            Returns <c>true</c> if the hook is installed, <c>false</c> otherwise. Every
            disposed or newly created hook will be marked as uninstalled.
            </summary>
        </member>
        <member name="P:EasyHook.LocalHook.GlobalThreadACL">
            <summary>
            Returns the gloabl thread ACL associated with ALL hooks. Refer to <see cref="M:EasyHook.LocalHook.IsThreadIntercepted(System.Int32)"/>
            for more information about access negotiation.
            </summary>
        </member>
        <member name="T:EasyHook.Config">
            <summary>
            Allows to setup EasyHook before it is actually loaded. You have to do this
            before using any other class contained in the EasyHook-Namespace!
            </summary>
            <remarks>
  The following demonstrates how to use <see cref="T:EasyHook.RemoteHooking"/> and <see cref="T:EasyHook.Config"/>:
  <code>
    using System;
    using System.Collections.Generic;
    using System.Runtime.Remoting;
    using System.Text;
    using System.IO;
    using EasyHook;

    namespace FileMon
    {
        public class FileMonInterface : MarshalByRefObject
        {
            public void IsInstalled(Int32 InClientPID)
            {
                Console.WriteLine("FileMon has been installed in target {0}.\r\n", InClientPID);
            }

            public void OnCreateFile(Int32 InClientPID, String[] InFileNames)
            {
                for (int i = 0; i &lt; InFileNames.Length; i++)
                {
                    Console.WriteLine(InFileNames[i]);
                }
            }

            public void ReportException(Exception InInfo)
            {
                Console.WriteLine("The target process has reported an error:\r\n" + InInfo.ToString());
            }

            public void Ping()
            {
            }
        }

        class Program
        {
            static String ChannelName = null;

            static void Main(string[] args)
            {
                try
                {
                    Config.Install(Environment.CurrentDirectory + "\\EasyHook.dll");
                    Config.Register(
                        "A FileMon like demo application.",
                        "FileMon.exe",
                        "FileMonInject.dll");

                    RemoteHooking.IpcCreateServer&lt;FileMonInterface&gt;(ref ChannelName, WellKnownObjectMode.SingleCall);

                    RemoteHooking.Inject(
                        Int32.Parse(args[0]),
                        InjectionOptions.None,
                        "FileMonInject.dll",
                        "FileMonInject.dll",
                        ChannelName);
                
                    Console.ReadLine();
                }
                catch (Exception ExtInfo)
                {
                    Console.WriteLine("There was an error while connecting to target:\r\n{0}", ExtInfo.ToString());
                }
            }
        }
    }
  </code>
</remarks>
        </member>
        <member name="M:EasyHook.Config.Install(System.String)">
            <summary>
            This method will setup the internal service paths and extract the proper
            files if they are not already there. All classes, except <see cref="T:EasyHook.Config"/>
            depend on those extracted files!
            </summary>
            <remarks>
            <para>
            If you inject a library into a target process, EasyHook will be
            loaded from the GAC, and so if you want to use injection, the service paths
            are usually unknown. To workaround this issue, you have to supply a path to
            EasyHook in the original host application. If your host is located in
            "C:\Program files\MyApp\" and EasyHook in "C:\Program files\MyApp\EasyHook.dll",
            you should call <see cref="M:EasyHook.Config.Install(System.String)"/> with the latter one as parameter in the
            target process which might be located in "C:\Program Files\HookedApp" for
            example. 
            </para>
            </remarks>
            <param name="InEasyHookPath">A relative or full qualified path to the main EasyHook.dll</param>
            <exception cref="T:System.InvalidProgramException">
            A required service file does already exist but has been modified!
            </exception>
            <exception cref="T:System.InvalidOperationException">
            It is not allowed to specify a path of a system directory.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">
            The given assembly file does not exist.
            </exception>
        </member>
        <member name="M:EasyHook.Config.Register(System.String,System.String[])">
            <summary>
            Installs EasyHook and all given user NET assemblies into the GAC and
            ensures that all references are cleaned up if the installing application
            is shutdown. Cleanup does not depend on the calling application...
            </summary>
            <remarks>
            <para>
            ATTENTION: There are some problems when debugging processes whose libraries
            are added to the GAC. Visual Studio won't start the debug session! There is
            only one chance for you to workaround this issue if you want to install
            libraries AND debug them simultanously. This is simply to debug only one process
            which is the default setting of Visual Studio. Because the libraries are added
            to the GAC AFTER Visual Studio has initialized the debug session, there won't be
            any conflicts; at least so far...
            </para><para>
            In debug versions of EasyHook, you may also check the "Application" event log, which holds additional information
            about the GAC registration, after calling this method. In general this method works
            transactionally. This means if something goes wrong the GAC state of all related libraries
            won't be violated!
            </para><para>
            The problem with NET assemblies is that the CLR only searches the GAC and
            directories starting with the application base directory for assemblies.
            To get injected assemblies working either all of them have to be located 
            under the target base directory (which is not suitable in most cases) or
            reside in the GAC. 
            </para><para>
            EasyHook provides a way to automatically register all of its own assemblies
            and custom ones temporarily in the GAC. It also ensures
            that all of these assemblies are removed if the installing process exists. 
            So you don't need to care about and may write applications according to
            the XCOPY standard. If your application ships with an installer, you may
            statically install all of your assemblies and the ones of EasyHook into the
            GAC. In this case just don't call <see cref="M:EasyHook.Config.Register(System.String,System.String[])"/>. 
            </para><para>
            Of course EasyHook does also take care of multiple processes using the same
            injection libraries. So if two processes are sharing some of those DLLs,
            a stable reference counter ensures that the libraries are kept in the GAC
            if one process is terminated while the other continues running and so continues
            holding a proper GAC reference.
            </para><para>
            Please note that in order to add your library to the GAC, it has to be a valid
            NET assembly and expose a so called "Strong Name". Assemblies without a strong
            name will be rejected by this method!
            </para>
            </remarks>
            <param name="InDescription">
            A description under which the installed files should be referenced. 
            </param>
            <param name="InUserAssemblies">
            A list of user assemblies as relative or absolute paths. 
            </param>
            <exception cref="T:System.InvalidOperationException">
            You have to call <see cref="M:EasyHook.Config.Install(System.String)"/> first.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">
            At least one of the files specified could not be found!
            </exception>
            <exception cref="T:System.BadImageFormatException">
            Unable to load at least one of the given files for reflection. 
            </exception>
            <exception cref="T:System.ArgumentException">
            At least one of the given files is not strongly named.
            </exception>
        </member>
        <member name="T:EasyHook.IEntryPoint">
            <summary>
            EasyHook will search in the injected user library for a class which implements
            this interface. You should only have one class exposing this interface, otherwise
            it is undefined which one will be choosen. 
            </summary>
            <remarks>
            <para>
            To implement this interface is not the only thing to do. The related class shall export
            two methods. The first one is <c>Initialize(IContext, ...)</c> which will let you initialize
            your library. You should immediately complete this call and only connect to your host
            application for further error reporting. This initialization method allows you to redirect
            all unhandled exceptions to your host application automatically. So even if all things in
            your library initialization would fail, you may still report exceptions! Such
            unhandled exceptions will be thrown by <see cref="M:EasyHook.RemoteHooking.Inject(System.Int32,EasyHook.InjectionOptions,System.String,System.String,System.Object[])"/> in your host. But
            make sure that you are using serializable exception objects only as all standard NET ones are,
            but not all custom ones. Otherwise you will only intercept a general exception with no specific
            information attached.
            </para><para>
            The second one is <c>Run(IContext, ...)</c> and should return if you want to unload your injected library. 
            Unhandled exceptions WON'T be redirected automatically. As you are expected to connect to
            your host in <c>Initialize()</c>, you are now also expected to report errors by yourself.
            </para><para>
            The parameter list described by <c>(IContext, ...)</c> will always contain a <see cref="T:EasyHook.RemoteHooking.IContext"/>
            instance as first parameter. All further parameters will depend on the arguments passed to <see cref="M:EasyHook.RemoteHooking.Inject(System.Int32,EasyHook.InjectionOptions,System.String,System.String,System.Object[])"/>
            at your injection host. <c>Initialize()</c> and <c>Run()</c> must have the same custom parameter list
            as composed by the one passed to <c>Inject()</c>. Otherwise an exception will be thrown. For example
            if you call <see cref="M:EasyHook.RemoteHooking.Inject(System.Int32,EasyHook.InjectionOptions,System.String,System.String,System.Object[])"/> with <c>Inject(..., ..., ..., ..., "MyString1", "MyString2")</c>, you
            have supplied a custom argument list of the format <c>String, String</c> to <c>Inject</c>. This list
            will be converted to an object array and serialized. The injected library stub will later
            deserialize this array and pass it to <c>Initialize()</c> and <c>Run()</c>, both expected to have
            a parameter of <c>IContext, String, String</c> in our case. So <c>Run</c> will now be called with
            <c>(IContext, "MyString1", "MyString2")</c>. I hope this is comprehensively explained ;-).
            </para><para>
            You shouldn't use static fields or properties within such a class, as this might lead to
            bugs in your code when multiple library instances are running in the same target!
            </para>
            </remarks>
        </member>
        <member name="T:EasyHook.InjectionOptions">
            <summary>
            All supported options that will influence the way your library is injected.
            </summary>
        </member>
        <member name="F:EasyHook.InjectionOptions.None">
            <summary>
            Use default settings. This will attach a debugger to the target, if you
            didn't set <see cref="P:EasyHook.Debugger.IsEnabled"/> to <c>false</c>. The debugger
            will be detached after your library has been injected. In general this provides
            the most reliable results.
            </summary>
        </member>
        <member name="F:EasyHook.InjectionOptions.AlwaysUseLocalSymbols">
            <summary>
            Will always assume that the target has the same symbol addresses like the current
            process. This assumption may be wrong in some cases in which the target would crash.
            But this flag ensures that no debugger is attached to the target. If you didn't set
            <see cref="P:EasyHook.Debugger.IsEnabled"/> to <c>false</c>, the debugger will still be attached
            to the current process to provide reliable symbol addresses. Of course this option
            will speed up the whole injection...
            </summary>
        </member>
        <member name="T:EasyHook.RemoteHooking">
            <summary>
            Provides all things related to library injection, inter-process-communication (IPC) and
            helper routines for common remote tasks.
            </summary>
            <remarks>
  The following demonstrates how to use <see cref="T:EasyHook.RemoteHooking"/> and <see cref="T:EasyHook.Config"/>:
  <code>
    using System;
    using System.Collections.Generic;
    using System.Runtime.Remoting;
    using System.Text;
    using System.IO;
    using EasyHook;

    namespace FileMon
    {
        public class FileMonInterface : MarshalByRefObject
        {
            public void IsInstalled(Int32 InClientPID)
            {
                Console.WriteLine("FileMon has been installed in target {0}.\r\n", InClientPID);
            }

            public void OnCreateFile(Int32 InClientPID, String[] InFileNames)
            {
                for (int i = 0; i &lt; InFileNames.Length; i++)
                {
                    Console.WriteLine(InFileNames[i]);
                }
            }

            public void ReportException(Exception InInfo)
            {
                Console.WriteLine("The target process has reported an error:\r\n" + InInfo.ToString());
            }

            public void Ping()
            {
            }
        }

        class Program
        {
            static String ChannelName = null;

            static void Main(string[] args)
            {
                try
                {
                    Config.Install(Environment.CurrentDirectory + "\\EasyHook.dll");
                    Config.Register(
                        "A FileMon like demo application.",
                        "FileMon.exe",
                        "FileMonInject.dll");

                    RemoteHooking.IpcCreateServer&lt;FileMonInterface&gt;(ref ChannelName, WellKnownObjectMode.SingleCall);

                    RemoteHooking.Inject(
                        Int32.Parse(args[0]),
                        InjectionOptions.None,
                        "FileMonInject.dll",
                        "FileMonInject.dll",
                        ChannelName);
                
                    Console.ReadLine();
                }
                catch (Exception ExtInfo)
                {
                    Console.WriteLine("There was an error while connecting to target:\r\n{0}", ExtInfo.ToString());
                }
            }
        }
    }
  </code>
</remarks>
        </member>
        <member name="M:EasyHook.RemoteHooking.ExecuteAsService``1(System.String,System.Object[])">
            <summary>
            Will execute the given static method under system privileges. 
            </summary>
            <remarks>
            <para>
            For some tasks it is necessary to have unrestricted access to the windows API.
            For example if you want to enumerate all running processes in all sessions. But
            keep in mind that you only can access these information within the given static
            method and only if it is called through this service.
            </para><para>
            To accomplish this task, your assembly is loaded into a system service which
            executes the given static method in a remote manner. This implies that the
            return type shall be marked with <see cref="T:System.SerializableAttribute"/>. All
            handles or other process specific things obtained in the service, will be invalid 
            in your application after the call is completed! Also the service will use
            a new instance of your class, so you should only rely on the given parameters
            and avoid using any external variables.. Your method shall be threaded as isolated!
            </para><para>
            The next thing to mention is that all assemblies required for executing the method
            shall either be in the GAC or in the directory of the related EasyHook-Library.
            Otherwise the service won't be able to use your assembly!
            </para><para>
            All unhandled exceptions will be rethrown by <see cref="M:EasyHook.RemoteHooking.ExecuteAsService``1(System.String,System.Object[])"/>.
            </para>
            </remarks>
            <typeparam name="TClass">A class containing the given static method.</typeparam>
            <param name="InMethodName">A public static method exposed by the given public class.</param>
            <param name="InParams">A list of serializable parameters being passed to your static method.</param>
            <returns>The same value your method is returning or <c>null</c> if a <c>void</c> method is called.</returns>
            <exception cref="T:System.AccessViolationException">
            The current user is not an administrator.
            </exception>
            <example>
  <code>
private static void OnProcessUpdate(Object InCallback)
{
    ProcessTimer.Change(Timeout.Infinite, Timeout.Infinite);

    try
    {
        ProcessInfo[] Array = (ProcessInfo[])RemoteHooking.ExecuteAsService&lt;Form1&gt;("EnumProcesses");
        SortedDictionary&lt;String, ProcessInfo&gt; Result = new SortedDictionary&lt;string, ProcessInfo&gt;();

        // sort by name...
        lock (ProcessList)
        {
            ActivePIDList.Clear();

            for (int i = 0; i &lt; Array.Length; i++)
            {
                Result.Add(System.IO.Path.GetFileName(Array[i].FileName) + "____" + i, Array[i]);

                ActivePIDList.Add(Array[i].Id);
            }

            Result.Values.CopyTo(Array, 0);

            ProcessList.Clear();

            ProcessList.AddRange(Array);
        }
    }
    catch (AccessViolationException)
    {
        MessageBox.Show("This is an administrative task!", "Permission denied...", MessageBoxButtons.OK);

        Process.GetCurrentProcess().Kill();
    }
    finally
    {
        ProcessTimer.Change(5000, 5000);
    }
}

[Serializable]
public class ProcessInfo
{
    public String FileName;
    public Int32 Id;
    public Boolean Is64Bit;
    public String User;
}

public static ProcessInfo[] EnumProcesses()
{
    List&lt;ProcessInfo&gt; Result = new List&lt;ProcessInfo&gt;();
    Process[] ProcList = Process.GetProcesses();

    for (int i = 0; i &lt; ProcList.Length; i++)
    {
        Process Proc = ProcList[i];

        try
        {
            ProcessInfo Info = new ProcessInfo();

            Info.FileName = Proc.MainModule.FileName;
            Info.Id = Proc.Id;
            Info.Is64Bit = RemoteHooking.IsX64Process(Proc.Id);
            Info.User = RemoteHooking.GetProcessIdentity(Proc.Id).Name;

            Result.Add(Info);
        }
        catch
        {
        }
    }

    return Result.ToArray();
}
  </code>
</example>
        </member>
        <member name="M:EasyHook.RemoteHooking.Inject(System.Int32,EasyHook.InjectionOptions,System.String,System.String,System.Object[])">
            <summary>
            Injects the given user library into the target process. No memory leaks are left
            in the target, even if injection fails for unknown reasons. 
            On Windows Vista (only with Service Pack 1!), it is no longer supported to inject into other
            terminal sessions except the current one and local system!
            </summary>
            <remarks>
            <para>
            There are two possible user library paths. The first one should map to
            a 32-bit library, and the second one should map to 64-bit library. If your
            code has been compiled for "AnyCPU", like it's the default for C#, you may
            even specify one library path for both parameters. Please note that your
            library including all of it's dependencies must be registered in the
            Global Assembly Cache (GAC). Refer to <see cref="M:EasyHook.Config.Register(System.String,System.String[])"/> for more
            information about how to get them there.
            </para><para>
            If you inject a library into any target process please keep in mind that
            your working directory will be switched. EasyHook will automatically add
            the directory of the injecting application as first directory of the target's PATH environment
            variable. So make sure that all required dependencies are either located
            within the injecting application's directory, a system directory or any directory defaultly
            contained in the PATH variable. As all managed assemblies have to be in the GAC
            there is no need for them being in any of those directories!
            </para> <para>
            EasyHook provides extensive error information during injection. Any kind of failure is
            being catched and thrown as an exception by this method. If for example your library
            does not expose a class implementing <see cref="T:EasyHook.IEntryPoint"/>, an exception will be
            raised in the target process during injection. This exception will be redirected to this method
            and you can catch it in a try-catch statement around <see cref="M:EasyHook.RemoteHooking.Inject(System.Int32,EasyHook.InjectionOptions,System.String,System.String,System.Object[])"/>.
            </para> <para>
            You will often have to pass parameters to your injected library. <see cref="T:System.Runtime.Remoting.Channels.Ipc.IpcChannel"/> 
            names are common, but also any other kind of data can be passed. You may add a custom list
            of objects marked with the <see cref="T:System.SerializableAttribute"/>. All common NET classes
            will be serializable by default, but if you are using your own classes you might have to provide
            serialization by yourself. The custom parameter list will be passed unchanged to your injected
            library entry points <c>Run</c> and <c>Initialize</c>. Verify that all required type libraries to deserialize
            your parameter list are in the GAC.
            </para><para>
            It is supported to inject code into 64-bit processes from within 32-bit processes and
            vice versa. It is also supported to inject code into other terminal sessions. Of course
            this will require additional processes and services to be created, but as they are managed
            internally, you won't notice them! There will be some delays when injecting the first library.
            Further injections are completed much faster!
            </para><para>
            Even if it would technically be possible to inject a library for debugging purposes into
            the current process, it will throw an exception. This is because it heavily depends on
            your injected library whether the current process will be damaged. Any kind of communication
            may lead into deadlocks if you hook the wrong APIs. Just use the capability of Visual Studio
            to debug more than one process simultanously which will allow you to debug your library
            as if it would be injected into the current process without running into any side-effects.
            </para>
            <para>
            The given exceptions are those which are thrown by EasyHook code. The NET framework might throw
            any other exception not listed here. Don't rely on the exception type. If you passed valid parameters,
            the only exceptions you should explicitly check for are <see cref="T:System.NotSupportedException"/> and
            <see cref="T:System.AccessViolationException"/>. All others
            shall be catched together and threaded as bad environment or invalid parameter error.
            </para>
            </remarks>
            <param name="InTargetPID">
            The target process ID.
            </param>
            <param name="InOptions">
            A valid combination of options.
            </param>
            <param name="InLibraryPath_x86">
            A partially qualified assembly name or a relative/absolute file path of the 32-bit version of your library. 
            For example "MyAssembly, PublicKeyToken=248973975895496" or ".\Assemblies\\MyAssembly.dll". 
            </param>
            <param name="InLibraryPath_x64">
            A partially qualified assembly name or a relative/absolute file path of the 64-bit version of your library. 
            For example "MyAssembly, PublicKeyToken=248973975895496" or ".\Assemblies\\MyAssembly.dll". 
            </param>
            <param name="InParams">
            A serializable list of parameters being passed to your library entry points <c>Run()</c> and
            <c>Initialize()</c>.
            </param>
            <exception cref="T:System.InvalidOperationException">
            It is unstable to inject libraries into the same process.
            </exception>
            <exception cref="T:System.AccessViolationException">
            Access to target process denied or the current user is not an administrator.
            </exception>
            <exception cref="T:System.ArgumentException">
            The given process does not exist or unable to serialize/deserialize one or more pass thru arguments.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">
            The given user library could not be found.
            </exception>
            <exception cref="T:System.OutOfMemoryException">
            Unable to allocate unmanaged memory in current or target process.
            </exception>
            <exception cref="T:System.NotSupportedException">
            It is not supported to inject into the target process. This is common on Windows Vista and Server 2008.
            </exception>
            <exception cref="T:System.TimeoutException">
            Unable to wait for user library to be initialized. Check your library <c>Initialize()</c> handler.
            </exception>
            <exception cref="T:System.InvalidProgramException">
            Your license does not include 64-Bit support.
            </exception>
            <exception cref="T:System.EntryPointNotFoundException">
            The given user library does not export a class implementing the <see cref="T:EasyHook.IEntryPoint"/> interface.
            </exception>
        </member>
        <member name="M:EasyHook.RemoteHooking.CreateAndInject(System.String,EasyHook.InjectionOptions,System.String,System.String,System.Object[])">
            <summary>
            Creates a new process which is started suspended until you call <see cref="M:EasyHook.RemoteHooking.WakeUpProcess"/>
            from within your injected library <c>Run()</c> method. This allows you to hook the target
            BEFORE any of its usual code is executed. In situations where a target has debugging and
            hook preventions, you will get a chance to block those mechanisms for example...
            </summary>
            <remarks>
            See <see cref="M:EasyHook.RemoteHooking.Inject(System.Int32,EasyHook.InjectionOptions,System.String,System.String,System.Object[])"/> for more information. The exceptions listed here are additional
            to the ones listed for <see cref="M:EasyHook.RemoteHooking.Inject(System.Int32,EasyHook.InjectionOptions,System.String,System.String,System.Object[])"/>.
            </remarks>
            <param name="InEXEPath">
            For security reasons an absolute path to the target executable is enforced.
            </param>
            <param name="InOptions">
            A valid combination of options.
            </param>
            <param name="InLibraryPath_x86">
            A partially qualified assembly name or a relative/absolute file path of the 32-bit version of your library. 
            For example "MyAssembly, PublicKeyToken=248973975895496" or ".\Assemblies\\MyAssembly.dll". 
            </param>
            <param name="InLibraryPath_x64">
            A partially qualified assembly name or a relative/absolute file path of the 64-bit version of your library. 
            For example "MyAssembly, PublicKeyToken=248973975895496" or ".\Assemblies\\MyAssembly.dll". 
            </param>
            <param name="InParams">
            A serializable list of parameters being passed to your library entry points <c>Run()</c> and
            <c>Initialize()</c>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The given file name is larger than <c>MAX_PATH (260)</c> characters in its full qualified form.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">
            The given EXE path could not be found.
            </exception>
        </member>
        <member name="M:EasyHook.RemoteHooking.WakeUpProcess">
            <summary>
            If the library was injected with <see cref="M:EasyHook.RemoteHooking.CreateAndInject(System.String,EasyHook.InjectionOptions,System.String,System.String,System.Object[])"/>, this will
            finally start the current process. You should call this method in the library
            <c>Run()</c> method after all hooks have been installed.
            </summary>
        </member>
        <member name="M:EasyHook.RemoteHooking.IsX64Process(System.Int32)">
            <summary>
            Determines if the target process is 64-bit or not. This will work only
            if the current process has <c>PROCESS_QUERY_INFORMATION</c> access to the target. 
            </summary>
            <remarks>
            A typical mistake is to enumerate processes under system privileges and 
            calling this method later when required. This won't work in most cases because
            you'll also need system privileges to run this method on processes in other sessions!
            </remarks>
            <param name="InTargetPID">The PID of the target process.</param>
            <returns><c>true</c> if the given process is 64-bit, <c>false</c> otherwise.</returns>
            <exception cref="T:System.AccessViolationException">
            The given process is not accessible.
            </exception>
            <exception cref="T:System.ArgumentException">
            The given process does not exist.
            </exception>
        </member>
        <member name="M:EasyHook.RemoteHooking.GetProcessIdentity(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Security.Principal.WindowsIdentity"/> of the user the target process belongs to.
            You need <c>PROCESS_QUERY_INFORMATION</c> access to the target.
            </summary>
            <param name="InTargetPID">An accessible target process ID.</param>
            <returns>The identity of the target owner.</returns>
            <exception cref="T:System.AccessViolationException">
            The given process is not accessible.
            </exception>
            <exception cref="T:System.ArgumentException">
            The given process does not exist.
            </exception>
        </member>
        <member name="M:EasyHook.RemoteHooking.GetCurrentProcessId">
            <summary>
            Returns the current native system process ID.
            </summary>
            <returns>The native system process ID.</returns>
        </member>
        <member name="M:EasyHook.RemoteHooking.GetCurrentThreadId">
            <summary>
            Returns the current native system thread ID. 
            </summary>
            <remarks>
            Even if currently each dedicated managed
            thread (not a thread from a <see cref="T:System.Threading.ThreadPool"/>) exactly maps to one native
            system thread, this behavior may change in future versions. 
            If you would like to have unintercepted threads, you should make sure that they are
            dedicated ones, e.g. derived from <see cref="T:System.Threading.Thread"/>.
            </remarks>
            <returns>The native system thread ID.</returns>
        </member>
        <member name="M:EasyHook.RemoteHooking.IpcConnectClient``1(System.String)">
            <summary>
            Connects to a globally reachable, managed IPC port.
            </summary>
            <remarks>
            All requests have to be made through the returned object instance.
            Please note that even if you might think that managed IPC is quiet slow,
            this is not usually the case. Internally a mechanism is being used to
            directly continue execution within the server process, so that even if 
            your thread does nothing while dispatching the request, no CPU time is lost,
            because the server thread seemlessly takes over exection. And to be true,
            the rare conditions in which you will need high-speed IPC ports are not
            worth the effort to break with NET's exciting IPC capabilities. In times
            of Quad-Cores, managed marshalling isn't that slow anymore.
            </remarks>
            <typeparam name="TRemoteObject">
            An object derived from <see cref="T:System.MarshalByRefObject"/> which provides the
            method implementations this server should provide. Note that only calls through the
            returned object instance will be redirected to the server process! ATTENTION: Static fields
            and members are always processed locally only...
            </typeparam>
            <param name="InChannelName">
            The name of the channel to connect to, usually obtained with <see cref="M:EasyHook.RemoteHooking.IpcCreateServer``1(System.Runtime.Remoting.WellKnownObjectMode,System.String@,System.Security.Principal.WellKnownSidType[])"/>.
            </param>
            <returns>
            An remote object instance which member accesses will be redirected to the server.
            </returns>
            <exception cref="T:System.ArgumentException">
            Unable to create remote object or invalid channel name...
            </exception>
        </member>
        <member name="M:EasyHook.RemoteHooking.IpcCreateServer``1(System.Runtime.Remoting.WellKnownObjectMode,System.String@,System.Security.Principal.WellKnownSidType[])">
            <summary>
            Creates a globally reachable, managed IPC-Port.
            </summary>
            <remarks>
            Because it is something tricky to get a port working for any constellation of
            target processes, I decided to write a proper wrapper method. Just keep the returned
            <see cref="T:System.Runtime.Remoting.Channels.Ipc.IpcChannel"/> alive, by adding it to a global list or static variable,
            as long as you want to have the IPC port open.
            </remarks>
            <typeparam name="TRemoteObject">
            A class derived from <see cref="T:System.MarshalByRefObject"/> which provides the
            method implementations this server should expose.
            </typeparam>
            <param name="InObjectMode">
            <see cref="F:System.Runtime.Remoting.WellKnownObjectMode.SingleCall"/> if you want to handle each call in an new
            object instance, <see cref="F:System.Runtime.Remoting.WellKnownObjectMode.Singleton"/> otherwise. The latter will implicitly
            allow you to use "static" remote variables.
            </param>
            <param name="RefChannelName">
            Either <c>null</c> to let the method generate a random channel name to be passed to 
            <see cref="M:EasyHook.RemoteHooking.IpcConnectClient``1(System.String)"/> or a predefined one. If you pass a value unequal to 
            <c>null</c>, you shall also specify all SIDs that are allowed to connect to your channel!
            </param>
            <param name="InAllowedClientSIDs">
            If no SID is specified, all authenticated users will be allowed to access the server
            channel by default. You must specify an SID if <paramref name="RefChannelName"/> is unequal to <c>null</c>.
            </param>
            <returns>
            An <see cref="T:System.Runtime.Remoting.Channels.Ipc.IpcChannel"/> that shall be keept alive until the server is not needed anymore.
            </returns>
            <exception cref="T:System.Security.HostProtectionException">
            If a predefined channel name is being used, you are required to specify a list of well known SIDs
            which are allowed to access the newly created server.
            </exception>
            <exception cref="T:System.Runtime.Remoting.RemotingException">
            The given channel name is already in use.
            </exception>
        </member>
        <member name="P:EasyHook.RemoteHooking.IsAdministrator">
            <summary>
            <c>true</c> if we are running with administrative privileges, <c>false</c> otherwise.
            </summary>
            <remarks>
            Due to UAC on Windows Vista, this property in general will be <c>false</c> even if the user is in
            the builtin-admin group. As you can't hook without administrator privileges you
            should just set the UAC level of your application to <c>requireAdministrator</c>.
            </remarks>
        </member>
        <member name="T:EasyHook.RemoteHooking.IContext">
            <summary>
            A context contains some basic information about the environment
            in which your library main method has been invoked. You will always
            get an instance of this interface in your library <c>Run</c> method
            and your library <c>Initialize</c> method. 
            </summary>
        </member>
        <member name="P:EasyHook.RemoteHooking.IContext.HostPID">
            <summary>
            Returns the process ID of the host that has injected this library.
            </summary>
        </member>
    </members>
</doc>
